{
    "componentChunkName": "component---src-templates-blog-post-tsx",
    "path": "/blog/sicp",
    "result": {"data":{"site":{"siteMetadata":{"title":"My personal Website"}},"markdownRemark":{"id":"540e77f2-8eac-5865-b630-890907e75e2f","excerpt":"Notes to the book Structure and Interpretation of Computer Programs, Second Edition\nHarold Abelson, Gerald Jay Sussman, Julie Sussman\nMIT Press My Github…","html":"<p>Notes to the book</p>\n<blockquote>\n<p>Structure and Interpretation of Computer Programs, Second Edition\nHarold Abelson, Gerald Jay Sussman, Julie Sussman\nMIT Press</p>\n</blockquote>\n<p><a href=\"https://github.com/LukasWoodtli/SchemeCourse\">My Github repository with examples</a></p>\n<p>See also <a href=\"%7Bfilename%7D/scheme.md\">Scheme (Lisp)</a></p>\n<p>[TOC]</p>\n<h1 id=\"1-building-abstractions-with-procedures\">1 Building Abstractions with Procedures</h1>\n<h2 id=\"11-the-elements-of-programming\">1.1 The Elements of Programming</h2>\n<p><em>“[The] language provides for combining simple ideas to form more complex ideas.  Every powerful language has three mechanisms for accomplishing this:</em></p>\n<ul>\n<li><em><strong>primitive expressions</strong>, which represent the simplest entities the language is concerned with,</em></li>\n<li><em><strong>means of combination</strong>, by which compound elements are built from simpler ones, and</em></li>\n<li><em><strong>means of abstraction</strong>, by which compound elements can be named and manipulated as units.”</em></li>\n</ul>\n<h3 id=\"113-evaluating-combinations\">1.1.3 Evaluating Combinations</h3>\n<p><em>“To evaluate a combination, do the following:</em></p>\n<ul>\n<li><em>Evaluate the subexpressions of the combination.</em></li>\n<li><em>Apply the procedure that is the value of the leftmost subexpression (the operator) to the arguments that are the values of the other subexpressions (the operands).</em>”</li>\n</ul>\n<p><em>”[…] first perform the evaluation process on each element of the combination. Thus, the evaluation rule is <strong>recursive</strong> in nature”</em></p>\n<h3 id=\"115-the-substitution-model-for-procedure-application\">1.1.5 The Substitution Model for Procedure Application</h3>\n<h4 id=\"applicative-order-versus-normal-order\">Applicative order versus normal order</h4>\n<p><em>“[The] interpreter first evaluates the operator and operands and then applies the resulting procedure to the resulting arguments.”</em></p>\n<p><em>“[An] alternative evaluation model would not evaluate the operands until their values were needed. Instead it would first substitute operand expressions for parameters until it obtained an expression involving only primitive operators, and would then perform the evaluation.”</em></p>\n<p><em>“This alternative ‘fully expand and then reduce’ evaluation method is known as <strong>normal-order evaluation</strong>, in contrast to the ‘evaluate the arguments and then apply’ method that the interpreter actually uses, which is called <strong>applicative-order evaluation</strong>.”</em></p>\n<p><em>“Normal-order and applicative-order evaluation produce the same value.”</em></p>\n<p><em>“Lisp uses applicative-order evaluation.”</em></p>\n<p><em>“Lisp obeys the convention that every expression has a value.”</em></p>\n<h3 id=\"121-linear-recursion-and-iteration\">1.2.1 Linear Recursion and Iteration</h3>\n<p><em>“In the iterative case, the program variables provide a complete description of the state of the process at any point.”</em></p>\n<p><em>“In contrasting iteration and recursion, we must be careful not to confuse the notion of a recursive <strong>process</strong> with the notion of a recursive <strong>procedure</strong> . When we describe a procedure as recursive, we are referring to the syntactic fact that the procedure definition refers (either directly or indirectly) to the procedure itself. But when we describe a process as following a pattern that is, say, linearly recursive, we are speaking about how the process evolves, not about the syntax of how a procedure is written.”</em></p>\n<p><em>“One reason that the distinction between process and procedure may be confusing is that most implementations of common languages (including Ada, Pascal, and C) are designed in such a way that the interpretation of any recursive procedure consumes an amount of memory that grows with the number of procedure calls, even when the process described is, in principle, iterative. As a consequence, these languages can describe iterative processes only by resorting to special-purpose ‘looping constructs’ such as <code class=\"language-text\">do</code>, <code class=\"language-text\">repeat</code>, <code class=\"language-text\">until</code>, <code class=\"language-text\">for</code>, and <code class=\"language-text\">while</code>.”</em></p>\n<p><em>“any iterative process can be realized ‘in hardware’ as a machine that has a fixed set of registers and no auxiliary memory. In contrast, realizing a recursive process requires a machine that uses an auxiliary data structure known as a <strong>stack</strong>.”</em></p>\n<h2 id=\"13-formulating-abstractions-with-higher-order-procedures\">1.3 Formulating Abstractions with Higher-Order Procedures</h2>\n<h3 id=\"132-constructing-procedures-using-lambda\">1.3.2 Constructing Procedures Using <code class=\"language-text\">lambda</code></h3>\n<h4 id=\"using-let-to-create-local-variables\">Using <code class=\"language-text\">let</code> to create local variables</h4>\n<p><em>“we could use a lambda expression to specify an anonymous procedure for binding our local variables</em></p>\n<p><em>The general form of a <code class=\"language-text\">let</code> expression is</em></p>\n<div class=\"gatsby-highlight\" data-language=\"scheme\"><pre class=\"language-scheme\"><code class=\"language-scheme\"><span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span>\n   <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token function\">&lt;var</span> 1> &lt;exp 1><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">(</span><span class=\"token function\">&lt;var</span> 2> &lt;exp 2><span class=\"token punctuation\">)</span>\n    ...\n    <span class=\"token punctuation\">(</span><span class=\"token function\">&lt;var</span> n> &lt;exp n><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  &lt;body><span class=\"token punctuation\">)</span></code></pre></div>\n<p><em>the <code class=\"language-text\">let</code> expression is interpreted as an alternate syntax for</em></p>\n<div class=\"gatsby-highlight\" data-language=\"scheme\"><pre class=\"language-scheme\"><code class=\"language-scheme\"><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">lambda</span> <span class=\"token punctuation\">(</span><span class=\"token lambda-parameter\">&lt;var 1> ... &lt;var n></span><span class=\"token punctuation\">)</span>\n  &lt;body><span class=\"token punctuation\">)</span>\n    &lt;exp 1>\n    ...\n    &lt;exp n><span class=\"token punctuation\">)</span></code></pre></div>\n<p><em>No new mechanism is required in the interpreter in order to provide local variables. A <code class=\"language-text\">let</code> expression is simply syntactic sugar for the underlying lambda application.”</em></p>\n<p><em>”<code class=\"language-text\">Let</code> allows one to bind variables as locally as possible to where they are to be used.”</em></p>\n<h4 id=\"abstractions-and-first-class-procedures\">Abstractions and first-class procedures</h4>\n<p><em>“programming languages impose restrictions on the ways in which computational elements can be manipulated. Elements with the fewest restrictions are said to have first-class status.”</em></p>\n<p><em>“Some of the ‘rights and privileges’ of first-class elements are:</em></p>\n<ul>\n<li><em>They may be named by variables.</em></li>\n<li><em>They may be passed as arguments to procedures.</em></li>\n<li><em>They may be returned as the results of procedures.</em></li>\n<li><em>They may be included in data structures.”</em></li>\n</ul>\n<h1 id=\"2-building-abstractions-with-data\">2 Building Abstractions with Data</h1>\n<h3 id=\"213-what-is-meant-by-data\">2.1.3 What Is Meant by Data?</h3>\n<p><em>“In general, we can think of data as defined by some collection of selectors and constructors, together with specified conditions that these procedures must fulfill in order to be a valid representation.”</em></p>\n<p><em>“we could implement <code class=\"language-text\">cons</code>, <code class=\"language-text\">car</code>, and <code class=\"language-text\">cdr</code> without using any data structures at all but only using procedures. Here are the definitions:</em></p>\n<div class=\"gatsby-highlight\" data-language=\"scheme\"><pre class=\"language-scheme\"><code class=\"language-scheme\"><span class=\"token punctuation\">(</span><span class=\"token keyword\">define</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">cons</span> x y<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">(</span><span class=\"token keyword\">define</span> <span class=\"token punctuation\">(</span><span class=\"token function\">dispatch</span> m<span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">(</span><span class=\"token keyword\">cond</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token operator\">=</span> m <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> x<span class=\"token punctuation\">)</span>\n          <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token operator\">=</span> m <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> y<span class=\"token punctuation\">)</span>\n              <span class=\"token punctuation\">(</span><span class=\"token keyword\">else</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">error</span> <span class=\"token string\">\"Argument not 0 or 1: CONS\"</span> m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n   dispatch<span class=\"token punctuation\">)</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">(define (car z)(z 0))\n(define (cdr z) (z 1))</code></pre></div>\n<h2 id=\"22-hierarchical-data-and-the-closure-property\">2.2 Hierarchical Data and the Closure Property</h2>\n<p><em>“The ability to create pairs whose elements are pairs is the essence of list structure’s importance as a representational tool. We refer to this ability as the <strong>closure property</strong> of cons. In general, an operation for combining data objects satisfies the closure property if the results of combining things with that operation can themselves be combined using the same operation.”</em></p>\n<h3 id=\"223-sequences-as-conventional-interfaces\">2.2.3 Sequences as Conventional Interfaces</h3>\n<h4 id=\"sequence-operations\">Sequence Operations</h4>\n<p><em>“The key to organizing programs so as to more clearly reflect the signal-flow structure is to concentrate on the ‘signals’ that flow from one stage in the process to the next. If we represent these signals as lists, then we can use list operations to implement the processing at each of the stages.”</em></p>\n<p><em>“The value of expressing programs as sequence operations is that this helps us make program designs that are modular, that is, designs that are constructed by combining relatively independent pieces. We can encourage modular design by providing a library of standard components together with a conventional interface for connecting the components in flexible ways.”</em></p>\n<p><em>“The Lisp community also (unfortunately) uses the word “closure” to describe a totally unrelated concept: A closure is an implementation technique for representing procedures with free variables.”</em></p>\n<p><em>“Unlike Lisp with its pairs, these languages have no built-in general-purpose glue that makes it easy to manipulate compound data in a uniform way.”</em></p>\n<h1 id=\"3-modularity-objects-and-state\">3 Modularity, Objects, and State</h1>\n<h2 id=\"31-assignment-and-local-state\">3.1 Assignment and Local State</h2>\n<h3 id=\"311-local-state-variables\">3.1.1 Local State Variables</h3>\n<p><em>“The <code class=\"language-text\">set!</code> special form, whose syntax is:”</em></p>\n<div class=\"gatsby-highlight\" data-language=\"scheme\"><pre class=\"language-scheme\"><code class=\"language-scheme\">set! &lt;name> &lt;new-value></code></pre></div>\n<p><em>“Here <code class=\"language-text\">&lt;name></code> is a symbol and <code class=\"language-text\">&lt;new-value></code> is any expression.\n<code class=\"language-text\">Set!</code> changes <code class=\"language-text\">&lt;name></code> so that its value is the result obtained by\nevaluating <code class=\"language-text\">&lt;new-value></code>.”</em></p>\n<p><em>“The value of a <code class=\"language-text\">set!</code> expression is implementation-dependent. <code class=\"language-text\">Set!</code> should be used only for its effect, not for its value.”</em></p>\n<h3 id=\"312-the-benefits-of-introducing-assignment\">3.1.2 The Benefits of Introducing Assignment</h3>\n<p><em>“From the point of view of one part of a complex process, the other parts appear to change with time. They have hidden time-varying local state. If we wish to write computer programs whose structure reflects this decomposition, we make computational objects whose behavior changes with time. We model state with local state variables, and we model the changes of state with assignments to those variables.”</em></p>\n<h3 id=\"313-the-costs-of-introducing-assignment\">3.1.3 The Costs of Introducing Assignment</h3>\n<h4 id=\"sameness-and-change\">Sameness and change</h4>\n<p><em>“A language that supports the concept that “equals can be substituted for equals” in an expression without changing the value of the expression is said to be referentially transparent. Referential transparency is violated when we include <code class=\"language-text\">set!</code> in our computer language. This makes it tricky to determine when we can simplify expressions by substituting equivalent expressions. Consequently, reasoning about programs that use assignment becomes drastically more difficult.”</em></p>\n<p><em>“The phenomenon of a single computational object being accessed by more than one name is known as aliasing.”</em></p>\n<h4 id=\"pitfalls-of-imperative-programming\">Pitfalls of imperative programming</h4>\n<p><em>“programs written in imperative style are susceptible to bugs that cannot occur in functional programs.”</em></p>\n<h2 id=\"32-the-environment-model-of-evaluation\">3.2 The Environment Model of Evaluation</h2>\n<p><em>“Once we admit assignment into our programming language […], a variable can no longer be considered to be merely a name for a value. Rather, a variable must somehow designate a “place” in which values can be stored. In our new model of evaluation, these places will be maintained in structures called environments.”</em></p>\n<p><em>“An environment is a sequence of frames. Each frame is a table (possibly empty) of bindings, which associate variable names with their corresponding values.”</em></p>\n<p><em>“Each frame also has a pointer to its enclosing environment […]. The value of a variable with respect to an environment is the value given by the binding of the variable in the first frame in the environment that contains a binding for that variable. If no frame in the sequence specifies a binding for the variable, then the variable is said to be unbound in the environment.”</em></p>\n<p><em>“Indeed, one could say that expressions in a programming language do not, in themselves, have any meaning. Rather, an expression acquires a meaning only with respect to some environment in which it is evaluated.”</em></p>\n<h3 id=\"321-the-rules-for-evaluation\">3.2.1 The Rules for Evaluation</h3>\n<p><em>“In the environment model of evaluation, a procedure is always a pair consisting of some code and a pointer to an environment. Procedures are created in one way only: by evaluating a <span class=\"math math-inline\"><span class=\"katex\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>λ</mi></mrow><annotation encoding=\"application/x-tex\">\\lambda</annotation></semantics></math></span></span>-expression. This produces a procedure whose code is obtained from the text of the <span class=\"math math-inline\"><span class=\"katex\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>λ</mi></mrow><annotation encoding=\"application/x-tex\">\\lambda</annotation></semantics></math></span></span>-expression and whose environment is the environment in which the <span class=\"math math-inline\"><span class=\"katex\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>λ</mi></mrow><annotation encoding=\"application/x-tex\">\\lambda</annotation></semantics></math></span></span>-expression was evaluated to produce the procedure.”</em></p>\n<p><em>“In general, <code class=\"language-text\">define</code> creates definitions by adding bindings to frames.”</em></p>\n<p><em>“Now that we have seen how procedures are created, we can describe how procedures are applied. The environment model specifies: To apply a procedure to arguments, create a new environment containing a frame that binds the parameters to the values of the arguments. The enclosing environment of this frame is the environment specified by the procedure. Now, within this new environment, evaluate the procedure body.”</em></p>\n<p><em>“The environment model of procedure application can be summarized by two rules:</em></p>\n<ul>\n<li>\n<p><em>A procedure object is applied to a set of arguments by constructing a frame, binding the formal parameters of the procedure to the arguments of the call, and then evaluating the body of the procedure in the context of the new environment constructed. The new frame has as its enclosing environment the environment part of the procedure object being applied.</em></p>\n</li>\n<li>\n<p><em>A procedure is created by evaluating a <span class=\"math math-inline\"><span class=\"katex\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>λ</mi></mrow><annotation encoding=\"application/x-tex\">\\lambda</annotation></semantics></math></span></span>-expression relative to a given environment. The resulting procedure object is a pair consisting of the text of the <span class=\"math math-inline\"><span class=\"katex\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>λ</mi></mrow><annotation encoding=\"application/x-tex\">\\lambda</annotation></semantics></math></span></span>-expression and a pointer to the environment in which the procedure was created.”</em></p>\n</li>\n</ul>\n<p><em>“We also specify that defining a symbol using <code class=\"language-text\">define</code> creates a binding in the current environment frame and assigns to the symbol the indicated value.”</em></p>\n<p><em>“Evaluating the expression (<code class=\"language-text\">set! &lt;variable> &lt;value></code>) in some environment locates the binding of the variable in the environment and changes that binding to indicate the new value. That is, one finds the first frame in the environment that contains a binding for the variable and modifies that frame. If the variable is unbound in the environment, then <code class=\"language-text\">set!</code> signals an error.”</em></p>\n<h2 id=\"33-modeling-with-mutable-data\">3.3 Modeling with Mutable Data</h2>\n<h3 id=\"331-mutable-list-structure\">3.3.1 Mutable List Structure</h3>\n<h4 id=\"sharing-and-identity\">Sharing and identity</h4>\n<p><em>“One way to detect sharing in list structures is to use the predicate <code class=\"language-text\">eq?</code>, […] as a way to test whether two symbols are equal. More generally, (<code class=\"language-text\">eq? x y</code>) tests whether <code class=\"language-text\">x</code> and <code class=\"language-text\">y</code> are the same object (that is, whether <code class=\"language-text\">x</code> and <code class=\"language-text\">y</code> are equal as pointers).”</em></p>\n<h4 id=\"mutation-is-just-assignment\">Mutation is just assignment</h4>\n<p><em>“We can implement mutable data objects as procedures using assignment and local state.”</em></p>\n<p><em>“Assignment is all that is needed, theoretically, to account for the behavior of mutable data. As soon as we admit <code class=\"language-text\">set!</code> to our language, we raise all the issues, not only of assignment, but of mutable data in general.”</em></p>\n<p><em>“On the other hand, from the viewpoint of implementation, assignment requires us to modify the environment, which is itself a mutable data structure. Thus, assignment and mutation are equipotent: Each can be implemented in terms of the other.”</em></p>\n<h1 id=\"4-metalinguistic-abstraction\">4 Metalinguistic Abstraction</h1>\n<h2 id=\"41-the-metacircular-evaluator\">4.1 The Metacircular Evaluator</h2>\n<p><em>“The model has two basic parts:</em></p>\n<ol>\n<li><em>To evaluate a combination (a compound expression other than a special form), evaluate the subexpressions and then apply the value of the operator subexpression to the values of the operand subexpressions.</em></li>\n<li><em>To apply a compound procedure to a set of arguments, evaluate the body of the procedure in a new environment. To construct this environment, extend the environment part of the procedure object by a frame in which the formal parameters of the procedure are bound to the arguments to which the procedure is applied.”</em></li>\n</ol>\n<p><em>“The job of the evaluator is not to specify the primitives of the language, but rather to\nprovide the connective tissue - the means of combination and the means of abstraction - that\nbinds a collection of primitives to form a language. Specifically:</em></p>\n<ul>\n<li><em>The evaluator enables us to deal with nested expressions.</em></li>\n<li><em>The evaluator allows us to use variables. […] We need an evaluator to keep track of variables and obtain their values before invoking the primitive procedures.</em></li>\n<li><em>The evaluator allows us to define compound procedures. This involves keeping track of procedure definitions, knowing how to use these definitions in</em> evaluating expressions, and providing a mechanism that enables procedures to accept arguments.*</li>\n<li><em>The evaluator provides the special forms, which must be evaluated differently from procedure calls.”</em></li>\n</ul>\n<h3 id=\"411-the-core-of-the-evaluator\">4.1.1 The Core of the Evaluator</h3>\n<p><em>“The evaluation process can be described as the interplay between two procedures:\n<code class=\"language-text\">eval</code> and <code class=\"language-text\">apply</code>.”</em></p>\n<h4 id=\"eval\">Eval</h4>\n<p><em>”<code class=\"language-text\">Eval</code> takes as arguments an expression and an environment. It classifies the expression\nand directs its evaluation. <code class=\"language-text\">Eval</code> is structured as a case analysis of the syntactic type\nof the expression to be evaluated.”</em></p>\n<p><em>“Each type of expression has a predicate that tests for it and an abstract means for\nselecting its parts. This <strong>abstract syntax</strong> makes it easy to see how we can change the\nsyntax of the language by using the same evaluator.”</em></p>\n<h4 id=\"primitive-expressions\">Primitive expressions</h4>\n<ul>\n<li><em>“For self-evaluating expressions, such as numbers, eval returns the expression itself.</em></li>\n<li><em>Eval must look up variables in the environment to find their values.</em></li>\n<li><em>For quoted expressions, <code class=\"language-text\">eval</code> returns the expression that was quoted.</em></li>\n<li><em>An assignment to (or a definition of) a variable must recursively call eval to compute the new value to be associated with the variable. The environment must be modified to change (or create) the binding of the variable.</em></li>\n<li><em>An <code class=\"language-text\">if</code> expression requires special processing of its parts, so as to evaluate the consequent if the predicate is true, and otherwise to evaluate the alternative.</em></li>\n<li><em>A <code class=\"language-text\">lambda</code> expression must be transformed into anapplicable procedure by packaging together the parameters and body specified by the <code class=\"language-text\">lambda</code> expression with the environment of the evaluation.</em></li>\n<li><em>A <code class=\"language-text\">begin</code> expression requires evaluating its sequence of expressions in the order in which they appear.</em></li>\n<li><em>A case analysis (<code class=\"language-text\">cond</code>) is transformed into a nest of <code class=\"language-text\">if</code> expressions and then evaluated.”</em></li>\n</ul>\n<h3 id=\"414-running-the-evaluator-as-a-program\">4.1.4 Running the Evaluator as a Program</h3>\n<p><em>“Our evaluator program reduces expressions ultimately to the application\nof primitive procedures.”</em></p>\n<p><em>“We thus set up a global environment that associates unique objects with the names\nof the primitive procedures that can appear in the expressions we will be evaluating.”</em></p>\n<p><em>“The global environment also includes bindings for the symbols <code class=\"language-text\">true</code> and <code class=\"language-text\">false</code>.”</em></p>\n<h3 id=\"415-data-as-programs\">4.1.5 Data as Programs</h3>\n<p><em>“Turing presented a simple computational model - now known\nas a <strong>Turing machine</strong> - and argued that any “effective process”\ncan be formulated as a program for such a machine. (This argument\nis known as the <strong>Church-Turing thesis</strong>.) Turing then implemented\na universal machine, i.e., a Turing machine that behaves\nas an evaluator for Turing-machine programs.”</em></p>\n<p><em>“An evaluator, which is\nimplemented by a relatively simple procedure, can emulate programs\nthat are more complex than the evaluator itself. The existence\nof a universal evaluator machine is a deep and wonderful\nproperty of computation.”</em></p>\n<h3 id=\"421-normal-order-and-applicative-order\">4.2.1 Normal Order and Applicative Order</h3>\n<p><em>“We noted that Scheme is an <strong>applicativeorder</strong>\nlanguage, namely, that all the arguments to Scheme\nprocedures are evaluated when the procedure is applied.\nIn contrast, <strong>normal-orde</strong>r languages delay evaluation of\nprocedure arguments until the actual argument values are\nneeded. Delaying evaluation of procedure arguments until\nthe last possible moment (e.g., until they are required by a\nprimitive operation) is called <strong>lazy evaluation</strong>”</em></p>\n<h3 id=\"422-an-interpreter-with-lazy-evaluation\">4.2.2 An Interpreter with Lazy Evaluation</h3>\n<p><em>“The basic idea is that, when applying a procedure, the interpreter\nmust determine which arguments are to be evaluated\nand which are to be delayed. The delayed arguments\nare not evaluated; instead, they are transformed into objects\ncalled <strong>thunks</strong>.”</em></p>\n<p><em>“The word <strong>thunk</strong> was invented by an informal working group that\nwas discussing the implementation of call-by-name in Algol 60.\nThey observed that most of the analysis of (“thinking about”) the\nexpression could be done at compile time; thus, at run time, the\nexpression would already have been “thunk” about”</em></p>\n<h2 id=\"43-variations-on-a-scheme---nondeterministic-computing\">4.3 Variations on a Scheme - Nondeterministic Computing</h2>\n<p><em>“With nondeterministic evaluation, an expression\nrepresents the exploration of a set of possible worlds,\neach determined by a set of choices. Some of the possible\nworlds lead to dead ends, while others have useful values.\nThe nondeterministic program evaluator supports the illusion\nthat time branches, and that our programs have different\npossible execution histories. When we reach a dead\nend, we can revisit a previous choice point and proceed\nalong a different branch.”</em></p>\n<h3 id=\"431-amb-and-search\">4.3.1 Amb and Search</h3>\n<p><em>“Abstractly, we can imagine that evaluating an <code class=\"language-text\">amb</code> expression\ncauses time to split into branches, where the\ncomputation continues on each branch with one of the\npossible values of the expression. We say that <code class=\"language-text\">amb</code> represents\na nondeterministic choice point.”</em></p>\n<p><em>“It is better to <strong>systematically search</strong> all possible execution paths.\nThe amb evaluator […] implements a systematic search as follows:\nWhen the evaluator encounters an application of `amb, it\ninitially selects the first alternative. This selection may itself\nlead to a further choice. The evaluator will always initially\nchoose the first alternative at each choice point. If\na choice results in a failure, then the evaluator <strong>automagically</strong>\nbacktracks to the most recent choice point and tries\nthe next alternative.”</em></p>\n<h3 id=\"433-implementing-the-amb-evaluator\">4.3.3 Implementing the Amb Evaluator</h3>\n<p><em>“The evaluation of an ordinary Scheme expression may return\na value, may never terminate, or may signal an error.\nIn nondeterministic Scheme the evaluation of an expression\nmay in addition result in the discovery of a dead\nend, in which case evaluation must backtrack to a previous\nchoice point. The interpretation of nondeterministic\nScheme is complicated by this extra case.”</em></p>\n<h4 id=\"execution-procedures-and-continuations\">Execution procedures and continuations</h4>\n<p><em>“Recall that the execution procedures for the ordinary evaluator\ntake one argument: the environment of execution.\nIn contrast, the execution procedures in the <code class=\"language-text\">amb</code> evaluator\ntake three arguments: the environment, and two procedures\ncalled <strong>continuation procedures</strong>. The evaluation of\nan expression will finish by calling one of these two continuations:\nIf the evaluation results in a value, the <strong>success\ncontinuation</strong> is called with that value; if the evaluation results\nin the discovery of a dead end, the <strong>failure continuation</strong>\nis called.”</em></p>\n<p><em>“The failure continuation\nin hand at that point will cause the most recent choice\npoint to choose another alternative. If there are no more\nalternatives to be considered at that choice point, a failure\nat an earlier choice point is triggered, and so on.”</em></p>\n<p><em>“In addition, if a side-effect operation (such as assignment\nto a variable) occurs on a branch of the process resulting\nfrom a choice, it may be necessary, when the process\nfinds a dead end, to undo the side effect before making\na new choice.”</em></p>\n<p><em>“When the failure continuation for an <code class=\"language-text\">amb</code> runs out of\nchoices, it calls the failure continuation that was originally\ngiven to the <code class=\"language-text\">amb</code>, in order to propagate the failure\nback to the previous choice point or to the top level.”</em></p>\n<h2 id=\"44-logic-programming\">4.4 Logic Programming</h2>\n<p><em>“Computer science deals with\nimperative (how to) knowledge, whereas mathematics\ndeals with declarative (what is) knowledge.”</em></p>\n<p><em>“In a nondeterministic language, expressions\ncan have more than one value, and, as a result, the\ncomputation is dealing with relations rather than with\nsingle-valued functions. Logic programming extends this\nidea by combining a relational vision of programming\nwith a powerful kind of symbolic pattern matching called\n<strong>unification</strong>.”</em></p>\n<h1 id=\"5-computing-with-register-machines\">5 Computing with Register Machines</h1>\n<h2 id=\"51-designing-register-machines\">5.1 Designing Register Machines</h2>\n<p><em>“To design a register machine, we must design its <strong>data paths</strong> (registers and operations) and the <strong>controller</strong> that sequences these operations.”</em></p>\n<h3 id=\"514-using-a-stack-to-implement-recursion\">5.1.4 Using a Stack to Implement Recursion</h3>\n<p><em>“Since there is no a priori limit on the depth of nested re- cursive calls, we may need to save an arbitrary number of register values. These values must be restored in the re- verse of the order in which they were saved, since in a nest of recursions the last subproblem to be entered is the first to be finished. This dictates the use of a <strong>stack</strong>.”</em></p>\n<p><em>“Although in principle the factorial computation requires an infinite machine, the machine in […] is actually finite except for the stack, which is potentially unbounded.”</em></p>\n<p><em>“When a recursive sub- problem is encountered, we save on the stack the registers whose current values will be required after the subproblem is solved, solve the recursive subproblem, then restore the saved registers and continue execution on the main problem.”</em></p>\n<p><em>“[The] registers that need to be saved depends on the particular machine, since not all recursive computations need the original values of registers that are modified during solution of the subproblem.”</em></p>\n<h3 id=\"522-the-assembler\">5.2.2 The Assembler</h3>\n<p><em>“The assembler transforms the sequence of controller expressions for a machine into a corresponding list of machine instructions, each with its execution procedure.”</em></p>\n<h2 id=\"53-storage-allocation-and-garbage-collection\">5.3 Storage Allocation and Garbage Collection</h2>\n<h3 id=\"531-memory-as-vectors\">5.3.1 Memory as Vectors</h3>\n<p><em>“Memory addresses can be incremented to support sequential access to some set of the cubbyholes. More generally, many important data operations require that memory addresses be treated as data, which can be stored in memory locations and manipulated in machine registers. The representation of list structure is one application of such <strong>address arithmetic</strong>.”</em></p>\n<p><em>“In order to describe memory operations, we use two primitive Scheme procedures for manipulating vectors:”</em></p>\n<ul>\n<li><code class=\"language-text\">(vector-ref &lt;vector> &lt;n>)</code> returns the <span class=\"math math-inline\"><span class=\"katex\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>n</mi><mrow><mi>t</mi><mi>h</mi></mrow></msup></mrow><annotation encoding=\"application/x-tex\">n^{th}</annotation></semantics></math></span></span> element of the vector.</li>\n<li><code class=\"language-text\">(vector-set! &lt;vector> &lt;n> &lt;value>)</code> sets the <span class=\"math math-inline\"><span class=\"katex\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>n</mi><mrow><mi>t</mi><mi>h</mi></mrow></msup></mrow><annotation encoding=\"application/x-tex\">n^{th}</annotation></semantics></math></span></span> element of the vector to the designated value.</li>\n</ul>\n<h4 id=\"representing-lisp-data\">Representing Lisp data</h4>\n<p><em>“Let us imagine that computer memory is divided into two vectors: <code class=\"language-text\">the-cars</code> and <code class=\"language-text\">the-cdrs</code>. We will represent list structure as follows: A pointer to a pair is an index into the two vectors. The <code class=\"language-text\">car</code> of the pair is the entry in <code class=\"language-text\">the-cars</code> with the designated index, and the <code class=\"language-text\">cdr</code> of the pair is the entry in <code class=\"language-text\">the-cdrs</code> with the designated index. We also need a representation for objects other than pairs (such as numbers and symbols) and a way to distinguish one kind of data from another. […] using <strong>typed pointers</strong>, that is, to extending the notion of “pointer” to include information on data type.”</em></p>\n<h3 id=\"532-maintaining-the-illusion-of-infinite-memory\">5.3.2 Maintaining the Illusion of Infinite Memory</h3>\n<p><em>“Garbage collection is based on the observation that, at any moment in a Lisp interpretation, the only objects that can affect the future of the computation are those that can be reached by some succession of <code class=\"language-text\">car</code> and <code class=\"language-text\">cdr</code> operations starting from the pointers that are currently in the machine registers.”</em></p>\n<p><em>“We assume here that the stack is represented as a list […], so that items on the stack are accessible via the pointer in the stack register.”</em></p>\n<h3 id=\"541-the-core-of-the-explicit-control-evaluator\">5.4.1 The Core of the Explicit-Control Evaluator</h3>\n<h4 id=\"evaluating-simple-expressions\">Evaluating simple expressions</h4>\n<p><em>“Numbers and strings (which are self-evaluating), variables, quotations, and <code class=\"language-text\">lambda</code> expressions have no subexpressions to be evaluated.”</em></p>\n<h4 id=\"evaluating-procedure-applications\">Evaluating procedure applications</h4>\n<p><em>“A procedure application is specified by a combination containing an operator and operands. The operator is a subexpression whose value is a procedure, and the operands are subexpressions whose values are the arguments to which the procedure should be applied.”</em></p>\n<p><em>“Saving registers whose contents will not be needed later may also hold onto useless data that could otherwise be garbage-collected, freeing space to be reused.”</em></p>\n<h3 id=\"544-running-the-evaluator\">5.4.4 Running the Evaluator</h3>\n<p><em>“we have explored successively more precise models of the evaluation process.\nWe started with the relatively informal substitution model, then extended this\n[…] to the environment model, which enabled us to deal with state and change.\nIn the metacircular evaluator […], we used Scheme itself as a language for\nmaking more explicit the environment structure constructed during evaluation of\nan expression. Now, with register machines, we have taken a close look at the\nevaluator’s mechanisms for storage management, argument passing, and control. At\neach new level of description, we have had to raise issues and resolve\nambiguities that were not apparent at the previous, less precise treatment of\nevaluation. To understand the behavior of the explicit-control evaluator, we can\nsimulate it and monitor its performance.”</em></p>\n<p><em>“There are two common strategies for bridging the gap between higher-level languages and register-machine languages.”</em></p>\n<p><em>“An interpreter written in the native language of a machine configures the\nmachine to execute programs written in a language (called the <strong>source language</strong>)\nthat may differ from the native language of the machine performing the\nevaluation. The primitive procedures of the source language are implemented as a\nlibrary of subroutines written in the native language of the given machine. A\nprogram to be interpreted (called the <strong>source program</strong>) is represented as a data\nstructure. The interpreter traverses this data structure, analyzing the source\nprogram. As it does so, it simulates the intended behavior of the source program\nby calling appropriate primitive subroutines from the library.”</em></p>\n<p><em>”[…] the alternative strategy of <strong>compilation</strong>. A compiler for a given\nsource language and machine translates a source program into an equivalent\nprogram (called the <strong>object program</strong>) written in the machine’s native\nlanguage.”</em></p>\n<p><em>“In view of the complementary advantages of compi-lation and interpretation,\nmodern program-development environments pursue a mixed strategy. Lisp\ninterpreters are generally organized so that interpreted procedures and\ncompiled procedures can call each other.”</em></p>\n<h3 id=\"551-structure-of-the-compiler\">5.5.1 Structure of the Compiler</h3>\n<h4 id=\"targets-and-linkages\">Targets and linkages</h4>\n<p><em>”<code class=\"language-text\">Compile</code> and the code generators that it calls take two arguments\nin addition to the expression to compile. There is a <strong>target</strong>,\nwhich specifies the register in which the compiled code is to return\nthe value of the expression. There is also a <strong>linkage descriptor</strong>,\nwhich describes how the code resulting from the compilation of the\nexpression should proceed when it has finished its execution. The\nlinkage descriptor can require that the code do one of the following\nthree things:</em></p>\n<ul>\n<li><em>continue at the next instruction in sequence (this is specified by the linkage descriptor <code class=\"language-text\">next</code>),</em></li>\n<li><em>return from the procedure being compiled (this is spec- ified by the linkage descriptor <code class=\"language-text\">return</code>), or</em></li>\n<li><em>jump to a named entry point (this is specified by using the designated label as the linkage descriptor).”</em></li>\n</ul>\n<h4 id=\"instruction-sequences-and-stack-usage\">Instruction sequences and stack usage</h4>\n<p><em>“An instruction sequence will contain three pieces of information:</em></p>\n<ul>\n<li><em>the set of registers that must be initialized before the instructions in the sequence are executed (these registers are said to be <strong>needed</strong> by the sequence),</em></li>\n<li><em>the set of registers whose values are modified by the instructions in the sequence, and</em>*</li>\n<li><em>the actual instructions (also called <strong>statements</strong>) in the sequence.”</em></li>\n</ul>\n<h3 id=\"556-lexical-addressing\">5.5.6 Lexical Addressing</h3>\n<p><em>“One of the most common optimizations performed by compilers is the optimization of variable lookup.”</em></p>\n<p><em>“Because our language is lexically scoped, the runtime environment\nfor any expression will have a structure that parallels the lexical\nstructure of the program in which the expression appears.”</em></p>\n<p><em>“This is not true if we allow internal definitions, unless we scan them out.”</em></p>\n<p><em>“We can exploit this fact by inventing a new kind of\nvariable-lookup operation, <code class=\"language-text\">lexical-address-lookup</code>, that takes as\narguments an environment and a <strong>lexical address</strong> that consists of\ntwo numbers: a <strong>frame number</strong>, which specifies how many frames to\npass over, and a <strong>displacement number</strong>, which specifies how many\nvariables to pass over in that frame.”</em></p>\n<p><em>“In order to generate such code, the compiler must be able to\ndetermine the lexical address of a variable it is about to compile a\nreference to.”</em></p>\n<h3 id=\"557-interfacing-compiled-code-to-the-evaluator\">5.5.7 Interfacing Compiled Code to the Evaluator</h3>\n<h4 id=\"interpretation-and-compilation\">Interpretation and compilation</h4>\n<p><em>“An interpreter raises the machine to the level of the user\nprogram; a compiler lowers the user program to the level of the\nmachine language. We can regard the Scheme language (or any\nprogramming language) as a coherent family of abstractions erected\non the machine language.”</em></p>\n<p><em>“We incur significant overhead if we insist that errors encountered\nin execution of a user program be detected and signaled, rather than\nbeing allowed to kill the system or produce wrong answers.”</em></p>","frontmatter":{"title":"Structure and Interpretation of Computer Programs","tags":["Lisp"],"category":"Programming"},"headings":[{"depth":1,"value":"1 Building Abstractions with Procedures"},{"depth":2,"value":"1.1 The Elements of Programming"},{"depth":3,"value":"1.1.3 Evaluating Combinations"},{"depth":3,"value":"1.1.5 The Substitution Model for Procedure Application"},{"depth":4,"value":"Applicative order versus normal order"},{"depth":3,"value":"1.2.1 Linear Recursion and Iteration"},{"depth":2,"value":"1.3 Formulating Abstractions with Higher-Order Procedures"},{"depth":3,"value":"1.3.2 Constructing Procedures Using <code class=\"language-text\">lambda</code>"},{"depth":4,"value":"Using <code class=\"language-text\">let</code> to create local variables"},{"depth":4,"value":"Abstractions and first-class procedures"},{"depth":1,"value":"2 Building Abstractions with Data"},{"depth":3,"value":"2.1.3 What Is Meant by Data?"},{"depth":2,"value":"2.2 Hierarchical Data and the Closure Property"},{"depth":3,"value":"2.2.3 Sequences as Conventional Interfaces"},{"depth":4,"value":"Sequence Operations"},{"depth":1,"value":"3 Modularity, Objects, and State"},{"depth":2,"value":"3.1 Assignment and Local State"},{"depth":3,"value":"3.1.1 Local State Variables"},{"depth":3,"value":"3.1.2 The Benefits of Introducing Assignment"},{"depth":3,"value":"3.1.3 The Costs of Introducing Assignment"},{"depth":4,"value":"Sameness and change"},{"depth":4,"value":"Pitfalls of imperative programming"},{"depth":2,"value":"3.2 The Environment Model of Evaluation"},{"depth":3,"value":"3.2.1 The Rules for Evaluation"},{"depth":2,"value":"3.3 Modeling with Mutable Data"},{"depth":3,"value":"3.3.1 Mutable List Structure"},{"depth":4,"value":"Sharing and identity"},{"depth":4,"value":"Mutation is just assignment"},{"depth":1,"value":"4 Metalinguistic Abstraction"},{"depth":2,"value":"4.1 The Metacircular Evaluator"},{"depth":3,"value":"4.1.1 The Core of the Evaluator"},{"depth":4,"value":"Eval"},{"depth":4,"value":"Primitive expressions"},{"depth":3,"value":"4.1.4 Running the Evaluator as a Program"},{"depth":3,"value":"4.1.5 Data as Programs"},{"depth":3,"value":"4.2.1 Normal Order and Applicative Order"},{"depth":3,"value":"4.2.2 An Interpreter with Lazy Evaluation"},{"depth":2,"value":"4.3 Variations on a Scheme - Nondeterministic Computing"},{"depth":3,"value":"4.3.1 Amb and Search"},{"depth":3,"value":"4.3.3 Implementing the Amb Evaluator"},{"depth":4,"value":"Execution procedures and continuations"},{"depth":2,"value":"4.4 Logic Programming"},{"depth":1,"value":"5 Computing with Register Machines"},{"depth":2,"value":"5.1 Designing Register Machines"},{"depth":3,"value":"5.1.4 Using a Stack to Implement Recursion"},{"depth":3,"value":"5.2.2 The Assembler"},{"depth":2,"value":"5.3 Storage Allocation and Garbage Collection"},{"depth":3,"value":"5.3.1 Memory as Vectors"},{"depth":4,"value":"Representing Lisp data"},{"depth":3,"value":"5.3.2 Maintaining the Illusion of Infinite Memory"},{"depth":3,"value":"5.4.1 The Core of the Explicit-Control Evaluator"},{"depth":4,"value":"Evaluating simple expressions"},{"depth":4,"value":"Evaluating procedure applications"},{"depth":3,"value":"5.4.4 Running the Evaluator"},{"depth":3,"value":"5.5.1 Structure of the Compiler"},{"depth":4,"value":"Targets and linkages"},{"depth":4,"value":"Instruction sequences and stack usage"},{"depth":3,"value":"5.5.6 Lexical Addressing"},{"depth":3,"value":"5.5.7 Interfacing Compiled Code to the Evaluator"},{"depth":4,"value":"Interpretation and compilation"}]}},"pageContext":{"id":"540e77f2-8eac-5865-b630-890907e75e2f","previousPost":{"title":"Scheme","slug":"/blog/scheme_frequently_used_functions"},"nextPost":{"title":"Modern C++ Design","slug":"/blog/modern_cpp_design"},"dates":{"created":1478814818,"modified":1647509701}}},
    "staticQueryHashes": []}