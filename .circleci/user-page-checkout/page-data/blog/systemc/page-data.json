{
    "componentChunkName": "component---src-templates-blog-post-tsx",
    "path": "/blog/systemc",
    "result": {"data":{"site":{"siteMetadata":{"title":"My personal Website"}},"markdownRemark":{"id":"4d4549f9-c367-5fe2-8195-9ded2bdfeffb","excerpt":"SystemC is a system-level modeling language. It’s implemented as a C++ library. The library is open source and platform independent. It contains an event-driven…","html":"<p>SystemC is a system-level modeling language. It’s implemented as a C++ library.</p>\n<p>The library is open source and platform independent.</p>\n<p>It contains an event-driven simulation kernel for executing models.</p>\n<p><a href=\"http://accellera.org/\">Accellera</a> is the main resource for SystemC.</p>\n<h1 id=\"simulation\">Simulation</h1>\n<p>SystemC contains a kernel for discrete-event driven simulation.\nThe main purpose of the kernel is to ensure to model concurrent activities (parallelism) correctly.</p>\n<p>The simulation clock represents the current value of the simulation time.</p>\n<p><img src=\"/fcbc5e197ae4da47719ade9b13e4de0f/systemc_simulation_engine.svg\" alt=\"Simulation Engine\">{: style=“float:right”}</p>\n<ul>\n<li>Initialization of simulation model\n<ul>\n<li>Set initial states of subsystem modules</li>\n<li>Fill event queue with initial events</li>\n</ul>\n</li>\n<li>Timing routine\n<ul>\n<li>Determine <em>next</em> event from event queue</li>\n<li>Advance simulation clock to the time when the event is to occur</li>\n</ul>\n</li>\n<li>Event routine\n<ul>\n<li>Update the system state when a particular type of event occurs</li>\n</ul>\n</li>\n</ul>\n<p>A more detailed description can be found on the <a href=\"https://www.doulos.com/knowhow/systemc/tutorial/primitive_channels/\">Doulos tutorial</a>:</p>\n<ol>\n<li>Initialization: execute all processes (except <code class=\"language-text\">SC_CTHREAD</code>s) in any (undefined) order</li>\n<li>Evaluation: select a process (ready to run) and resume its execution\n<ul>\n<li>This may cause immediate event notifications to occur</li>\n<li>which may result in additional processes being made ready to run in this same phase</li>\n</ul>\n</li>\n<li>Repeat step 2. until there are no processes ready to run</li>\n<li>Update: execute all pending calls to <code class=\"language-text\">update()</code> resulting from calls to <code class=\"language-text\">request_update()</code> made in step 2.</li>\n<li>If there were any delta event notifications made during steps 2. or 4.\n<ul>\n<li>determine which processes are ready to run due to all those events and go back to step 2.</li>\n</ul>\n</li>\n<li>If there are no timed events: simulation is finished</li>\n<li>Advance the simulation time to the time of the earliest pending timed event notification</li>\n<li>Determine which processes are ready to run due to all the timed events at what is now the current time\n<ul>\n<li>go back to step 2.</li>\n</ul>\n</li>\n</ol>\n<p>(note: the list above is taken mostly from the Doulos tutorial)</p>\n<h2 id=\"delta-cycle\">Delta Cycle</h2>\n<p>Within the same simulation cycle <em>cause</em> and <em>effect</em> events may share the same time of occurrence.</p>\n<p>The simulator uses a zero duration <em>virtual time interval</em>: delta cycle</p>\n<p>The delta cycle is the smallest simulated time slot. It consist of two phases:</p>\n<ol>\n<li>Evaluation phase</li>\n<li>Update phase</li>\n</ol>\n<p>Separating the two phases makes it possible to guarantee deterministic behavior.\nA channel will not change it’s value until the update phase occurs.\nIt cannot change the value during the evaluation phase.</p>\n<p>It’s possible to run a process without the update phase (without the delta cycle) with <code class=\"language-text\">notify()</code>.</p>\n<h1 id=\"constructs\">Constructs</h1>\n<h2 id=\"modules\">Modules</h2>\n<p>Building blocks of SystemC models.</p>\n<ul>\n<li>Hierarchy (subsystems)</li>\n<li>Abstraction</li>\n<li>IP reuse</li>\n</ul>\n<p>Modules are called by the simulation engine if an relevant event is scheduled.</p>\n<p>Modules process events, manipulate the event queue and contain (and manipulate) the system state.</p>\n<h2 id=\"processes\">Processes</h2>\n<p>Processes must be contained in a module.</p>\n<ul>\n<li><code class=\"language-text\">SC_THREAD</code>\n<ul>\n<li>Typically called once, run in an endless loop</li>\n<li>Can be suspended with <code class=\"language-text\">wait()</code></li>\n<li>Keep the state of execution implicitly</li>\n</ul>\n</li>\n<li><code class=\"language-text\">SC_METHOD</code>\n<ul>\n<li>Execute repeatedly form beginning to end</li>\n<li>Simulate <em>faster</em></li>\n<li>Do <em>not</em> keep state of execution implicitly</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"wait-and-notify\">Wait and Notify</h3>\n<ul>\n<li>wait: halt process execution until an event is raised\n<ul>\n<li><code class=\"language-text\">wait()</code></li>\n<li>wait with arguments: dynamic sensitivity\n<ul>\n<li><code class=\"language-text\">wait(sc_event)</code></li>\n<li><code class=\"language-text\">wait(time)</code></li>\n<li><code class=\"language-text\">wait(time_out, sc_event)</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>notify: raise an event (method of <code class=\"language-text\">sc_event</code> class)\n<ul>\n<li><code class=\"language-text\">my_event.notify()</code>: immediate notification. Processes sensitive to the event will run during current evaluation phase</li>\n<li>notify with arguments: delayed notification\n<ul>\n<li><code class=\"language-text\">my_event.notify(SC_ZERO_TIME)</code>: notify during evaluation phase of next delta cycle</li>\n<li><code class=\"language-text\">my_event.notify(time)</code>: notify after <em>time</em> (in evaluation phase of that delta cycle)</li>\n</ul>\n</li>\n<li>notify allows non-deterministic behavior</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"communication\">Communication</h2>\n<ul>\n<li>Event\n<ul>\n<li>Flexible</li>\n<li>low-level synchronization primitive</li>\n</ul>\n</li>\n<li>Channel\n<ul>\n<li>Container for\n<ul>\n<li>Communication and</li>\n<li>Synchronization</li>\n</ul>\n</li>\n<li>Can have state (private data), transport data/events</li>\n<li>Implement one or more <em>interfaces</em></li>\n</ul>\n</li>\n<li>Interface\n<ul>\n<li>Set of access methods to channel</li>\n<li>Interface methods need to be implemented (pure virtual)</li>\n</ul>\n</li>\n</ul>\n<p>Other communication and synchronization models can be built\nbased on these primitives.</p>\n<h3 id=\"channels\">Channels</h3>\n<ul>\n<li>Separating communication from behavior</li>\n<li>Interfaces define access to channel</li>\n<li>Ports are used to access the channel</li>\n</ul>\n<h1 id=\"non-determinism\">Non-Determinism</h1>\n<p>SystemC allows for non-determinism. This might not be acceptable for hardware modeling.\nBut it can be needed for software system modeling.</p>\n<p>An example of non-determinism can be found here: <a href=\"https://www.doulos.com/knowhow/systemc/tutorial/primitive_channels/\">Doulos: Primitive Channels and the Kernel</a>.</p>\n<p>It shows two threads (<code class=\"language-text\">SC_THREAD</code>s) in a module that both access the same variable. It’s not known in\nwhich order the variable is accessed.</p>\n<p>In software systems a mutex might be needed to control the access to the variable.</p>","frontmatter":{"title":"SystemC","tags":["Computer Science","C++","Embedded Systems"],"category":"Programming"},"headings":[{"depth":1,"value":"Simulation"},{"depth":2,"value":"Delta Cycle"},{"depth":1,"value":"Constructs"},{"depth":2,"value":"Modules"},{"depth":2,"value":"Processes"},{"depth":3,"value":"Wait and Notify"},{"depth":2,"value":"Communication"},{"depth":3,"value":"Channels"},{"depth":1,"value":"Non-Determinism"}]}},"pageContext":{"id":"4d4549f9-c367-5fe2-8195-9ded2bdfeffb","previousPost":{"title":"Open Source Software","slug":"/blog/open_source"},"nextPost":{"title":"Models of Computation","slug":"/blog/models_of_computation"},"dates":{"created":1455574730,"modified":1647509701}}},
    "staticQueryHashes": []}