{
    "componentChunkName": "component---src-templates-blog-post-tsx",
    "path": "/blog/executable_loader",
    "result": {"data":{"site":{"siteMetadata":{"title":"My personal Website"}},"markdownRemark":{"id":"140b7ff7-42aa-5941-845b-a46818575b81","excerpt":"Most information of this page is taken from\nCalling conventions for different C++ compilers and operating systems. Some other good information sources are…","html":"<p>Most information of this page is taken from\n<a href=\"http://www.agner.org/optimize/#manuals\">Calling conventions for different C++ compilers and operating systems</a>.</p>\n<p>Some other good information sources are:</p>\n<p><a href=\"http://www.iecc.com/linker/\">Linkers and Loaders</a></p>\n<p><a href=\"https://en.wikipedia.org/wiki/Linker_%28computing%29\">Wikipedia:Linker</a></p>\n<p><a href=\"https://en.wikipedia.org/wiki/Loader_%28computing%29\">Wikipedia:Loader</a></p>\n<p><a href=\"https://en.wikipedia.org/wiki/Relocation_%28computing%29\">Wikipedia:Relocation</a></p>\n<p>Book: Computer Systems: A Programmer’s Perspective, Randal E. Bryant, David R. O’Hallarom</p>\n<blockquote>\n<p>Most explanations on this page are for the x86 platform!</p>\n</blockquote>\n<p>Modern OS’s allow to load executable code at runtime. This can be\ncomplete programms or (dynamic) libraries.</p>\n<p>On UNIX a dynamic library is called <em>shared object</em>. On Windows it’s\ncalled <em>dynamic link library (dll)</em>.</p>\n<p>The OS needs to load the code to a specific position in memory and\nit needs to adjust any internal references and addresses.</p>\n<p>This loading is done in a simmilar way in most OS.</p>\n<p>The relocation of the executable image is done according to the\nimage base.</p>\n<p>The image base is the virtal memory address at which the image is\nloaded.</p>\n<p>The load-time relocation can be avoided if the image base is fixed.</p>\n<p>The most common values for the image base are:</p>\n<ul>\n<li>Windows (32-bit, 64-bit): 0x400000</li>\n<li>Linux (32-bit): 0x8048000</li>\n<li>Linux (64-bit): 0x400000</li>\n<li>Mach-O (32-bit): 0x1000</li>\n<li>Mach-O (64-bit): 0x100000000</li>\n</ul>\n<p>Dynamic libraries can’t be loaded at a fixed image base.</p>\n<p>There are three aproaches for loading executables without fixed image base:</p>\n<ol>\n<li>\n<p>The executable (or library) contains a relocation table. This contains\nall cross-references in the file. The loader adjusts all these\ncross-references if the executable is loaded at another base address\nthen the the one chosen by the linker.</p>\n<p>This aproach is used by Windows (32-bit, 64-bit)</p>\n</li>\n<li>\n<p>The executable is designed position independant. All addresses are\ncalculated at runtime relative to <em>IP</em>.</p>\n<p>This aproach is used on OS X (Intel)</p>\n</li>\n<li>\n<p>The shared object contains a Global Offset Table (GOT). In the GOT\nare the addressrs of static objects stored. The addresses in the GOT\nare afjusted by the loader according to the base address.\nCode that accesses static data points to the GOT and the GOT\nthen points to the data.</p>\n<p>This aproach is often used in Linux (32-bit) and BSD</p>\n</li>\n</ol>\n<h1 id=\"difference-between-relocation-table-and-global-offset-table-got\">Difference between Relocation Table and Global Offset Table (GOT)</h1>\n<h2 id=\"relocation-table\">Relocation Table</h2>\n<p>Relocation table is not changed when shared object is loaded.\nThe relocation table points to data references in the code.\nThese references are modified in place.</p>\n<h2 id=\"global-offset-table-got\">Global Offset Table (GOT)</h2>\n<p>The GOT is changed by the loader. So the entries in the GOT point\nto the new (relocated) addresses. Static data references in the\ncode still point to the GOT but the entries in the GOT were updated.</p>\n<h1 id=\"function-calls-across-shared-objects-dlls\">Function calls across shared objects (DLLs)</h1>\n<p>Shared objects can have references to functions in other shared objects.\nUsually calls to these functions go through an import table in the\nexecutable (shared object) file.</p>\n<p>Either the loader fills the import table at load time or it is lazy\ninitialized for each function when it is called the first time.</p>","frontmatter":{"title":"Executable Loader","tags":["Computer Science"],"category":"Programming"},"headings":[{"depth":1,"value":"Difference between Relocation Table and Global Offset Table (GOT)"},{"depth":2,"value":"Relocation Table"},{"depth":2,"value":"Global Offset Table (GOT)"},{"depth":1,"value":"Function calls across shared objects (DLLs)"}]}},"pageContext":{"id":"140b7ff7-42aa-5941-845b-a46818575b81","previousPost":{"title":"Preprocessor Defines","slug":"/blog/preprocessor_defines"},"nextPost":{"title":"Undo Committed Changes with SVN","slug":"/blog/svn_undo_committed_changes"},"dates":{"created":1439308725,"modified":1647509701}}},
    "staticQueryHashes": []}