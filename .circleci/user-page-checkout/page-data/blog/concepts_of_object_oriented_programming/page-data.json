{
    "componentChunkName": "component---src-templates-blog-post-tsx",
    "path": "/blog/concepts_of_object_oriented_programming",
    "result": {"data":{"site":{"siteMetadata":{"title":"My personal Website"}},"markdownRemark":{"id":"d01f61f5-7e70-563e-8b2a-7b5bee0243f6","excerpt":"[TOC] Core Requirements to OOP Languages Highly dynamic execution model Cooperating program parts with well defined interfaces Classification (hierarchy) and…","html":"<p>[TOC]</p>\n<h1 id=\"core-requirements-to-oop-languages\">Core Requirements to OOP Languages</h1>\n<ul>\n<li>Highly dynamic execution model</li>\n<li>Cooperating program parts with well defined interfaces</li>\n<li>Classification (hierarchy) and specialisation (reuse)</li>\n<li>Quality/Correctness</li>\n</ul>\n<h1 id=\"the-object-model\">The Object Model</h1>\n<ul>\n<li>A software system is a set of cooperating objects</li>\n<li>Objects have state (fields) and processing ability (methods)</li>\n<li>Objects exchange messages (methods)</li>\n</ul>\n<p>Objects have:</p>\n<ul>\n<li>State</li>\n<li>Identity</li>\n<li>Lifecycle</li>\n<li>Location</li>\n<li>Behavior</li>\n</ul>\n<blockquote>\n<p>Objects are different form values!</p>\n</blockquote>\n<p>Values don’t have the above properties.</p>\n<h2 id=\"interfaces-and-encapsulation\">Interfaces and Encapsulation</h2>\n<ul>\n<li>Objects have well-defined interfaces\n<ul>\n<li>Publicly accessible fields</li>\n<li>Publicly accessible methods</li>\n</ul>\n</li>\n<li>Implementation is hidden behind interface\n<ul>\n<li>Encapsulation</li>\n<li>Information hiding</li>\n</ul>\n</li>\n<li>Interfaces are the basis for describing behavior</li>\n</ul>\n<h2 id=\"classification-and-polymorphism\">Classification and Polymorphism</h2>\n<ul>\n<li>Classification: Hierarchical structuring of objects (‘is-a’-Relation)</li>\n<li>Objects belong to different classes simultaneously</li>\n<li><em>Substitution principle</em>: Subtype objects can be used wherever supertype objects are expected</li>\n</ul>\n<blockquote>\n<p>Child &#x3C;: Parent</p>\n</blockquote>\n<h3 id=\"classification\">Classification</h3>\n<ul>\n<li>We can classify objects or fields (?)</li>\n<li>Classifications can be <em>trees</em> or <em>DAGs</em></li>\n<li>Classifications of objects form “is-a” relation</li>\n<li>Classes can be abstract or concrete</li>\n</ul>\n<blockquote>\n<p>Substitution Principle: Objects of subtypes can be used wherever</p>\n</blockquote>\n<p>objects of supertypes are expected</p>\n<h3 id=\"polymorphism\">Polymorphism</h3>\n<h4 id=\"subtype-polymorphism\">Subtype Polymorphism</h4>\n<ul>\n<li>Direct consequence of substitution principle</li>\n<li>Run-time (dynamic) Polymorphism</li>\n<li>Dynamic (late) binding</li>\n</ul>\n<h4 id=\"parametric-polymorphism\">Parametric Polymorphism</h4>\n<ul>\n<li>Generic types</li>\n<li>Uses <em>type parameters</em></li>\n<li>One implementation can be used for different types</li>\n<li>Type missmatch detected at compile time</li>\n<li>C++ Templates, Generics (Java, C#)</li>\n</ul>\n<h4 id=\"method-overloading\">Method Overloading</h4>\n<ul>\n<li>Ad-Hoc Polymorphism</li>\n<li>Overloading: Methods with same name but different arguments</li>\n</ul>\n<h3 id=\"spezialization\">Spezialization</h3>\n<ul>\n<li>Start from general objects/types</li>\n<li>Extend these objecs (fields and methods)</li>\n<li>Behaviour of specialized objects need to be compliant to more general objects! (Substitution Principle)</li>\n<li>Progam parts that work for the genral objects work also for specialized objects</li>\n<li>Methods can be <em>overridden</em></li>\n</ul>\n<h1 id=\"types-and-subtyping\">Types and Subtyping</h1>\n<h2 id=\"types\">Types</h2>\n<p>Type systems can be analyzed in three dimensions:</p>\n<ol>\n<li>Weak and Strong Type Systems</li>\n<li>Nominal and Structural Types</li>\n<li>Static and Dynamic Type Checking</li>\n</ol>\n<p>Definition:</p>\n<blockquote>\n<p>A type is a set of values sharing some properties. A value <em>v</em> has type <em>T</em> if <em>v</em> is an element of <em>T</em>.</p>\n</blockquote>\n<p><em>T</em> is a set that contains all possible values <em>v</em>.</p>\n<h3 id=\"weak-and-strong-type-systems\">Weak and Strong Type Systems</h3>\n<p>How strongly or weakly typed a language is concerns casting (implicit and explicit).\nIt’s mainly used to compare languages to each other about the possible castings, type safety and information loss.</p>\n<h4 id=\"untyped-languages\">Untyped Languages</h4>\n<ul>\n<li>Not classifying values into types, just bit patterns</li>\n<li>i.e. Assembler</li>\n</ul>\n<h4 id=\"weakly-typed-languages\">Weakly Typed Languages</h4>\n<ul>\n<li>Classifying values into types</li>\n<li>No strict enforcement of restrictions, i.e Multiplying two pointers is possible</li>\n<li>i.e. C, C++</li>\n</ul>\n<h4 id=\"strongly-typed-languages\">Strongly Typed Languages</h4>\n<ul>\n<li>Classify values into types</li>\n<li>Enforcing that all operations are applied to values of appropriate type</li>\n<li>Strongly-typed languages prevent certain erroneous or undesirable program behavior</li>\n<li>i.e. Java, Python, Scala, Smalltalk, Eiffel, C#</li>\n<li>Most Dynamic Languages (i.e Python, JavaScript) are Strongly Typed</li>\n</ul>\n<h3 id=\"nominal-and-structural-types\">Nominal and Structural Types</h3>\n<h4 id=\"nominal-types\">Nominal Types</h4>\n<ul>\n<li>Based on type names</li>\n<li>i.e. C++, Java, Eiffel, Scala</li>\n</ul>\n<h4 id=\"structural-types\">Structural Types</h4>\n<ul>\n<li>Based on available methods and fields</li>\n<li>i.e. Python, Ruby, Smalltals</li>\n</ul>\n<h3 id=\"type-checking\">Type Checking</h3>\n<p>Type checking prevents certain errors in programm.</p>\n<p>When happens the type checking?</p>\n<ul>\n<li>Static: Compile time</li>\n<li>Dynamic: Run time</li>\n</ul>\n<h4 id=\"static-type-checking\">Static Type Checking</h4>\n<ul>\n<li>Types of variables and methods are declared explicitly or inferred</li>\n<li>Types of expressions can be derived from the types of their constituents</li>\n<li>Type rules are used at <em>compile time</em> to check whether a program is correctly typed</li>\n</ul>\n<blockquote>\n<p>A programming language is called type-safe if its design prevents type errors</p>\n</blockquote>\n<p>Pros:</p>\n<ul>\n<li>Static safety</li>\n<li>Readability (type annotations are a good documentation)</li>\n<li>Efficiency</li>\n</ul>\n<h4 id=\"dynamic-type-checking\">Dynamic Type Checking</h4>\n<ul>\n<li>Variables, methods, and expressions of a program are typically not typed (types not declared)</li>\n<li>Every object and value has a type</li>\n<li><em>Run-time system checks</em> that operations are applied to expected arguments</li>\n<li>Also static languages need to performe some checks dynamically at run-time (i.e type-casting)</li>\n<li>Dynamic languages are usually more expressive (no type annotations)</li>\n</ul>\n<p>Pros:</p>\n<ul>\n<li>Expressiveness</li>\n<li>Low overhead (no type annotations)</li>\n<li>Much simpler</li>\n</ul>\n<h3 id=\"overview-of-type-systems-in-oo-languages\">Overview of Type Systems in OO-Languages</h3>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>Static</th>\n<th>Dynamic</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Nominal</td>\n<td>C++, Java, Eiffel, Scala, C#</td>\n<td>certain features of statically-typed languages</td>\n</tr>\n<tr>\n<td>Structural</td>\n<td>Research languages: O’Caml, Moby…</td>\n<td>Python, JavaScript, Ruby, Smalltalk</td>\n</tr>\n</tbody>\n</table>\n<p>Dynamic and Structural is often called “duck typing”.</p>\n<h2 id=\"subtyping\">Subtyping</h2>\n<blockquote>\n<p>Substitution principle Objects of subtypes can be used wherever objects of supertypes are expected</p>\n</blockquote>\n<ul>\n<li>Syntactic classification: Subtypes understand <em>at least the messages</em> of their supertypes.\n<ul>\n<li>Nominal languages: Subtype has a <em>wider</em> (or same) interface as supertype</li>\n<li>Overriding methods must not be less accessible</li>\n</ul>\n</li>\n<li>Semantic classification: Subtypes provide <em>at least the behaviour</em> of their supertypes.</li>\n</ul>\n<p>A type is a <em>set</em> of values. <em>Subtype relation</em> corresponds to <em>subset relation</em>.</p>\n<p><img src=\"/52e2ed13656b3877631179d403ca0a49/coop_subtyping_and_sets.svg\" alt=\"Subtyping and Sets\"></p>\n<ul>\n<li>In <em>nominal</em> programming languages the <em>programmer</em> decides about subtype relation</li>\n<li>In <em>structural</em> programming languages the <em>type checker</em> decides about subtype relation</li>\n</ul>\n<h3 id=\"variance-covariance-contravariance-and-invariance\">Variance (Covariance, Contravariance and Invariance)</h3>\n<p>Based on substitution principle.</p>\n<h4 id=\"covariance\">Covariance</h4>\n<p>Ordering of types from more specific to more generic (in direction of inheritance hierarchy)</p>\n<p><img src=\"/f30f4d1cc1a5609c91d940023d77e8ef/covariance.svg\" alt=\"Covariance\"></p>\n<h4 id=\"contravariance\">Contravariance</h4>\n<p>Ordering of types from more generic to more specific (in oposite direction of inheritance hierarchy)</p>\n<p><img src=\"/3c82e8aecf6d30193ce0d8f6c11af095/contravariance.svg\" alt=\"Contravariance\"></p>\n<h4 id=\"variance-for-oop\">Variance for OOP</h4>\n<p><a href=\"https://class.coursera.org/progfun-005/lecture/83\">Coursera:Scala</a></p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>Variance</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Input Arguments</td>\n<td>Contravariant</td>\n</tr>\n<tr>\n<td>Return Values and Exceptions</td>\n<td>Covariant</td>\n</tr>\n<tr>\n<td>In- and Output Arguments (Mutable Reference Arguments)</td>\n<td>Nonvariant</td>\n</tr>\n</tbody>\n</table>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\">SuperReturnType <span class=\"token class-name\">Super</span><span class=\"token double-colon punctuation\">::</span><span class=\"token function\">foo</span><span class=\"token punctuation\">(</span>SubParamType p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// |         ^ contra-</span>\n<span class=\"token comment\">//  ..                        ^             // |         | variant</span>\n<span class=\"token comment\">//   v                        ..            // | co-     |</span>\nSubReturnType   <span class=\"token class-name\">Sub</span><span class=\"token double-colon punctuation\">::</span><span class=\"token function\">foo</span><span class=\"token punctuation\">(</span>SuperParamType p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// v variant |</span></code></pre></div>\n<p><em>Super</em> is more <strong>general</strong> than <em>Sub</em>.</p>\n<p><em>Sub</em> is more <strong>specific</strong> than <em>Super</em>.</p>\n<table>\n<thead>\n<tr>\n<th>Programming Language</th>\n<th>Return Type</th>\n<th>Argument Type</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>C++, Java, Scala, D…</td>\n<td>Covariant</td>\n<td>Nonvariant</td>\n</tr>\n<tr>\n<td>Eiffel</td>\n<td>Covariant</td>\n<td>Covariant</td>\n</tr>\n<tr>\n<td>C#</td>\n<td>Nonvariant</td>\n<td>Nonvariant</td>\n</tr>\n</tbody>\n</table>\n<!-- End of Notes Week 2 -->\n<p>In Java and C# arrays are covariant!</p>\n<h3 id=\"behavioral-subtyping-contracts\">Behavioral Subtyping (Contracts)</h3>\n<p>What are the <em>properties</em> shared by the values of a type?</p>\n<p><em>Properties</em> should also include the behavior of the object.\nThis is expressed as interface specifications (contracts)</p>\n<ul>\n<li>Precondition: Have to hold before the method is executed</li>\n<li>Postcondition: Have to hold after the method has terminated</li>\n<li>Old-expressons: Can be used to refer to prestate values from the postcondition</li>\n<li>Invariant: Have to hold in all states in which an object can be accessed by other objects</li>\n</ul>\n<h4 id=\"subtyping-and-contracs\">Subtyping and Contracs</h4>\n<ul>\n<li>Subtypes must fulfill contracts of supertypes</li>\n<li>Overriding method of subtypes may have <em>weaker preconditions</em> than the supertype method</li>\n<li>Overriding method of subtypes may have <em>stronger postconditions</em> than the supertype method</li>\n<li>Subtypes may have <em>stronger invariants</em> than supertypes</li>\n<li>Subtypes may have <em>stronger history constrains</em> than supertype</li>\n</ul>\n<!-- Beginning of Notes Week 4 -->\n<h4 id=\"specification-inheritance-inherit-contracts-from-subtypes\">Specification Inheritance (Inherit Contracts from Subtypes)</h4>\n<ul>\n<li>Subtype needs to satisfy the contract of the supertype (inheriting contracts)</li>\n<li><em>Invariant</em> inheritance: Conjunction (AND) of own contract and contracts of all supertypes</li>\n<li><em>History</em> inheritance: same as for <em>invariants</em></li>\n<li><em>Precondition</em> inheritance: Disjunctions (OR) of own contract and contracts of all supertypes</li>\n</ul>\n<div class=\"math math-display\"><span class=\"katex\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>P</mi><mi>r</mi><mi>e</mi><mi>E</mi><mi>f</mi><msub><mi>f</mi><mrow><mi>S</mi><mi mathvariant=\"normal\">.</mi><mi>m</mi></mrow></msub><mo>=</mo><mi>P</mi><mi>r</mi><msub><mi>e</mi><mrow><mi>S</mi><mi mathvariant=\"normal\">.</mi><mi>m</mi></mrow></msub><mi mathvariant=\"normal\">∣</mi><mi mathvariant=\"normal\">∣</mi><mi>P</mi><mi>r</mi><msub><mi>e</mi><mrow><mi>T</mi><mi mathvariant=\"normal\">.</mi><mi>m</mi></mrow></msub><mi mathvariant=\"normal\">∣</mi><mi mathvariant=\"normal\">∣</mi><mi>P</mi><mi>r</mi><msub><mi>e</mi><mrow><msup><mi>T</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mi mathvariant=\"normal\">.</mi><mi>m</mi></mrow></msub><mi mathvariant=\"normal\">∣</mi><mi mathvariant=\"normal\">∣</mi><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi></mrow><annotation encoding=\"application/x-tex\">PreEff_{S.m} = Pre_{S.m} || Pre_{T.m} || Pre_{T'.m} || ...</annotation></semantics></math></span></div>\n<ul>\n<li><em>Postcondition</em> inheritance: Satisfy <em>each</em> postcondition for which the corresponding precondition holds\n<ul>\n<li>Precondition needs to be evaluated with <em>old</em> state</li>\n</ul>\n</li>\n</ul>\n<div class=\"math math-display\"><span class=\"katex\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>P</mi><mi>o</mi><mi>s</mi><mi>t</mi><mi>E</mi><mi>f</mi><msub><mi>f</mi><mrow><mi>S</mi><mi mathvariant=\"normal\">.</mi><mi>m</mi></mrow></msub><mo>=</mo><mo stretchy=\"false\">(</mo><mi>o</mi><mi>l</mi><mi>d</mi><mo stretchy=\"false\">(</mo><mi>P</mi><mi>r</mi><msub><mi>e</mi><mrow><mi>S</mi><mi mathvariant=\"normal\">.</mi><mi>m</mi></mrow></msub><mo stretchy=\"false\">)</mo><mo>=</mo><mo>></mo><mi>P</mi><mi>o</mi><mi>s</mi><msub><mi>t</mi><mrow><mi>S</mi><mi mathvariant=\"normal\">.</mi><mi>m</mi></mrow></msub><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">&#x26;</mi><mi mathvariant=\"normal\">&#x26;</mi><mo stretchy=\"false\">(</mo><mi>o</mi><mi>l</mi><mi>d</mi><mo stretchy=\"false\">(</mo><mi>P</mi><mi>r</mi><msub><mi>e</mi><mrow><mi>T</mi><mi mathvariant=\"normal\">.</mi><mi>m</mi></mrow></msub><mo stretchy=\"false\">)</mo><mo>=</mo><mo>></mo><mi>P</mi><mi>o</mi><mi>s</mi><msub><mi>t</mi><mrow><mi>T</mi><mi mathvariant=\"normal\">.</mi><mi>m</mi></mrow></msub><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">&#x26;</mi><mi mathvariant=\"normal\">&#x26;</mi><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi></mrow><annotation encoding=\"application/x-tex\">PostEff_{S.m} = (old(Pre_{S.m}) => Post_{S.m}) \\&#x26;\\&#x26; (old(Pre_{T.m}) => Post_{T.m}) \\&#x26;\\&#x26; ...</annotation></semantics></math></span></div>\n<h3 id=\"types-as-contracts\">Types as Contracts</h3>\n<p>Types can be seen as a kind of contracts.</p>\n<p>Overriding Methods must:</p>\n<table>\n<thead>\n<tr>\n<th>Behavioral Subtyping (contracts)</th>\n<th>Nominal/Structural Subtyping (variance)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Weaker Preconditions</td>\n<td>Covariant Parameters</td>\n</tr>\n<tr>\n<td>Stronger Postconditions</td>\n<td>Covariant Results</td>\n</tr>\n<tr>\n<td>Stronger Invariants</td>\n<td>Invariant fields</td>\n</tr>\n</tbody>\n</table>\n<p>This doesn’t apply exactly to:</p>\n<ul>\n<li>Invariants/Fields</li>\n<li>History constraints</li>\n</ul>\n<!-- End of Slides 2 -->\n<h2 id=\"inheritance\">Inheritance</h2>\n<!-- Notes Week 4 01:18:05  p. 4 -->\n<h3 id=\"difference-between-inheritance-and-subtyping\">Difference between inheritance and subtyping</h3>\n<p>Inheritance allows to reuse the code (specialization) inside a class\n(member variables and method definitions).</p>\n<p>Subtyping supports reuse externally. It’s used for polymorphism\nin form of the substitution principle.</p>\n<p>Subtyping expresses classification.</p>\n<p>Subtypeing depends only on the interface of objects and not on their\nimplementations.</p>\n<p>In most existing OOP languages inheritance also is subtyping.\nC++ allows private (or protected) inheritance which does not result\nin subtyping.\nWith interfaces (Java, C++…) it’s possible to create subtypes\nwithout inheritance (no reuse of code from parent class).\nUsually the term “inherit from an interface” is used even if it’s\nnot correct.</p>\n<blockquote>\n<p>Subclassing = Subtyping + Inheritance</p>\n</blockquote>\n<p>Inheritance is <em>not</em> a core concept of OOP.</p>\n<p>OOP can do without inheritance, but not without subtyping!</p>\n<h2 id=\"aggregation-vs-private-inheritance-c\">Aggregation vs. Private Inheritance (C++)</h2>\n<ul>\n<li>Both solutions allow code reuse without establishing a subtype relation</li>\n<li>No subtype polymorphism</li>\n<li>No behavioral subtyping  equirements</li>\n</ul>\n<p>Aggregation causes more overhead</p>\n<ul>\n<li>Two objects at run-time</li>\n<li>Boilerplate code for delegation</li>\n<li>Access methods for protected fields</li>\n</ul>\n<p>Private inheritance may lead to unnecessary multiple inheritance</p>\n<h2 id=\"static-and-dynamic-method-binding\">Static and Dynamic Method Binding</h2>\n<ul>\n<li>Static binding: Methods are selected based on the <em>static type</em> of the</li>\n</ul>\n<p>receiver <em>at compile time</em></p>\n<ul>\n<li>Dynamic binding: Methods are selected based on the <em>dynamic type</em> of the</li>\n</ul>\n<p>receiver object <em>at run time</em></p>\n<p>Dynamic method binding enables specialization and subtype polymorphism</p>\n<p>Drawbacks</p>\n<ul>\n<li>Performance: Overhead of method look-up at run-time</li>\n<li>Versioning: Dynamic binding makes it harder to evolve code</li>\n</ul>\n<p>without breaking subclasses</p>\n<p>Defaults</p>\n<ul>\n<li>Dynamic binding: Eiffel, Java, Scala, dynamically-typed languages</li>\n<li>Static  binding: C++, C#</li>\n</ul>\n<h3 id=\"static-method-binding-in-java\">Static Method binding in Java</h3>\n<p>Java binds methods statically in 3 cases:</p>\n<ol>\n<li>Static Methods</li>\n<li>Private Methods</li>\n<li>Method calls on <code class=\"language-text\">super</code></li>\n</ol>\n<h2 id=\"rules-for-proper-subclassing\">Rules for proper Subclassing</h2>\n<ul>\n<li>Use subclassing only if there is an <em>‘is-a’</em> relation\n<ul>\n<li>Syntactic and behavioral subtypes</li>\n</ul>\n</li>\n<li>Do not rely on implementation details</li>\n<li>Use precise documentation (<em>contracts</em> where possible)</li>\n<li>When evolving superclasses, <em>do not mess around with dynamically-bound methods</em></li>\n<li>Do not add or remove calls, or change order of calls</li>\n<li>Do not specialize superclasses that are expected to change often</li>\n</ul>\n<h1 id=\"binary-methods\">Binary Methods</h1>\n<p>Binary methods take one explicit argument and receiver (this)</p>\n<p>Often behavior should be specialized depending on the dynamic types\nof <em>both</em> arguments.</p>\n<p>Recall that covariant parameter types are not statically type-safe! (?)</p>\n<ul>\n<li>Dynamic binding for specialization based on dynamic type of <em>receiver</em></li>\n<li>How to specialize on the dynamic type of the <em>explicit argument</em>?</li>\n<li>Visitor Pattern: tedious to write, requires modification of superclass</li>\n</ul>\n<p>Some Languages Support Multiple Dispatch:</p>\n<p>Method calls are bound on dynamic types of several arguments.</p>\n<ul>\n<li>Performance overhead</li>\n<li>Extra requirements are needed to ensure there is a “unique best method” for every call</li>\n</ul>\n<h1 id=\"multiple-inheritance\">Multiple Inheritance</h1>\n<p>All OOP languages support multiple subtyping:</p>\n<ul>\n<li>One type can have several supertypes</li>\n<li>Subtype relation forms a DAG</li>\n</ul>\n<p>Some languages support multiple inheritance.</p>\n<h2 id=\"problems-with-multiple-inheritance\">Problems with multiple inheritance</h2>\n<p>Ambiguities:</p>\n<ul>\n<li>Superclasses may contain fields and methods with identical names and signatures</li>\n<li>Which version should be available in the subclass?</li>\n</ul>\n<p>Repeated inheritance (diamonds):</p>\n<ul>\n<li>A class may inherit from a superclass more than once</li>\n<li>How many copies of the superclass members are there?</li>\n<li>How are the superclass fields initialized?</li>\n</ul>\n<h1 id=\"mixins-and-traits\">Mixins and Traits</h1>\n<p>TODO</p>\n<p>…</p>\n<!-- Beginning of Slides 4.2 Parametric Polymorphism p. 61 (29) -->\n<!-- Beginning of Notes Week 7 p. 8 -->\n<h1 id=\"parametric-polymorphism-1\">Parametric Polymorphism</h1>\n<h2 id=\"java-c-\">Java, C#, …</h2>\n<ul>\n<li>Subtype relation not always desiderable</li>\n<li>Generics (Java, Scala, C#)</li>\n<li>Upper bounds (<code class=\"language-text\">extends</code>): Subtype of upper bound required\n<ul>\n<li>Guarantees that a specific method can be called</li>\n<li>Modular check of implementation of Generic code</li>\n</ul>\n</li>\n<li>Generics (in Java, C#) are non-variant\n<ul>\n<li>Covariance is unsafe when client <strong>writes</strong> to generic type argument (‘input’)\n<ul>\n<li>Mutable fields</li>\n<li>Method arguments</li>\n</ul>\n</li>\n<li>Contravariance is unsafe when client <strong>reads</strong> from generic type argument (‘output’)\n<ul>\n<li>Fields</li>\n<li>Method results</li>\n</ul>\n</li>\n<li>Non-variance is sometimes too restrictive</li>\n</ul>\n</li>\n<li>Scala allows variance-annotation\n<ul>\n<li>Positive positions (‘output’, <em>covariant</em>): <code class=\"language-text\">+</code>\n<ul>\n<li>Result type</li>\n<li>Type of immutable fields</li>\n</ul>\n</li>\n<li>Negative positions (‘input’, <em>contravariant</em>): <code class=\"language-text\">-</code>\n<ul>\n<li>Parameter type</li>\n</ul>\n</li>\n<li>C# uses keywords <code class=\"language-text\">in</code> and <code class=\"language-text\">out</code></li>\n</ul>\n</li>\n</ul>\n<!-- End of Notes Week 7 -->\n<!-- Beginning of Notes Week 8 -->\n<ul>\n<li>Methods can also have type arguments (i.e <code class=\"language-text\">static &lt;T> void printAll(Collection&lt;T> c) {...}</code>)</li>\n</ul>\n<h3 id=\"wildcards\">Wildcards</h3>\n<p>Wildcards can be seen as an <a href=\"https://en.wikipedia.org/wiki/Type_system#Existential_types\">Existential Type</a>:</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">printAll</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Collection</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> c<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span> e <span class=\"token operator\">:</span> c<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<blockquote>\n<p>There exits a type argument <code class=\"language-text\">T</code> such that <code class=\"language-text\">c</code> has type <code class=\"language-text\">collection&lt;T></code></p>\n</blockquote>\n<ul>\n<li>\n<p>Wildcards can have a <em>upper bounds</em> and <em>lower bounds</em> (correspond to <em>co- and contravariance</em>)</p>\n<ul>\n<li>upper bound for <em>reading</em> and method invocation: <code class=\"language-text\">extends</code></li>\n<li>lower bound <em>writing</em>: <code class=\"language-text\">super</code></li>\n</ul>\n</li>\n<li>\n<p>lower bounds are not supported on type parameters (only on wildcards) in Java</p>\n</li>\n</ul>\n<p>Instantiation of wildcards can change over time:</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Wrapper</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token class-name\">Cell</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> data<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token comment\">// client code:</span>\n<span class=\"token class-name\">Wrapper</span> w <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Wrapper</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nw<span class=\"token punctuation\">.</span>data <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Cell</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// w.data has type Cell&lt;String></span>\nw<span class=\"token punctuation\">.</span>data <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Call</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Object</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// now w.data has type Cell&lt;Object>!</span></code></pre></div>\n<ul>\n<li>\n<p>Generics with wildcards (and possibly with bounds) have a subtype relation if the type parameters have a relation</p>\n<ul>\n<li>See <a href=\"https://docs.oracle.com/javase/tutorial/java/generics/subtyping.html\">Java documentation</a></li>\n</ul>\n</li>\n<li>\n<p>Type Erasure (Java, Scala)</p>\n<ul>\n<li>For backwards compatibility (in JVM)</li>\n<li>Generic type information is erased in compiler (not available in bytecode anymore)\n<ul>\n<li><code class=\"language-text\">C&lt;T></code> is translated to <code class=\"language-text\">C</code></li>\n<li><code class=\"language-text\">T</code> is translated to its <em>upper bound</em></li>\n<li>Casts are added wher nessecary (i.e reading values from generic type)</li>\n<li>Only one classfile and one class object for all instantiations of a generic class</li>\n<li>Run-time type information (<code class=\"language-text\">instanceof</code>, <code class=\"language-text\">List&lt;String>.class</code>) is <em>missing</em></li>\n<li>Arrays of generic types are <em>not possible</em> (<code class=\"language-text\">new List&lt;String>[10]</code>)</li>\n<li>Static fields are shared by all instantiations of a generic class</li>\n<li>Lower bounds for type parameters would require support in JVM (bytecode verification)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>No Type Erasure in C#</p>\n<ul>\n<li>Run-type type information is available</li>\n<li>Arrays of generic types are possible</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"c-templates\">C++ Templates</h2>\n<ul>\n<li>Classes and Methods (Functions) can be parametrized</li>\n<li>Also value types can be used as templates paramters</li>\n<li>Instantiation generates (internally) a new class</li>\n<li>Type checking is done on of the generated class, not on the template (different to Java, C#, …)\n<ul>\n<li>Type check only of the parts of code that are used</li>\n<li>Type errors are not detectes before instantination</li>\n<li>No bounds needed</li>\n</ul>\n</li>\n<li>No subtype releation between instantiations of a template</li>\n<li>No run-time support needed (templates are a compilation concept)</li>\n<li>Templates can be specialized</li>\n<li>Improvement for feature C++ standard (C++17): <a href=\"https://en.wikipedia.org/wiki/Concepts_%28C%2B%2B%29\">Concepts Lite</a>\n<ul>\n<li><em>Structural</em> upper bounds (C++ type system is nominal)</li>\n</ul>\n</li>\n<li><a href=\"https://en.wikipedia.org/wiki/Template_metaprogramming\">Template Meta Programming</a>\n<ul>\n<li>Is touring-complete!</li>\n</ul>\n</li>\n</ul>\n<!-- End of Slides 4.2 -->\n<!-- End of Notes Week 8 -->\n<h1 id=\"information-hiding-and-encapsulation\">Information Hiding and Encapsulation</h1>\n<!-- Beginning of Slides 5 -->\n<!-- Beginning of Notes Week 9 -->\n<p>In the literature Information Hiding and Encapsulation are often used synonymously.\nBut they are distinct but related.</p>\n<h2 id=\"information-hiding\">Information Hiding</h2>\n<blockquote>\n<p>Information hiding is used to reduce dependencies between modules. The client is\nprovided only the information needed.</p>\n</blockquote>\n<ul>\n<li>Concerns static parts of program (code)</li>\n<li>Syntactic and semantic: Contracts are part of the exported interfaces</li>\n<li>Reduce dependencies\n<ul>\n<li>Classes can be studied in isolation</li>\n<li>Classes only interact in well-defined ways</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"client-interface-of-a-class\">Client Interface of a Class</h3>\n<ul>\n<li>Class Name</li>\n<li>Type parameters (Generics) and their bounds</li>\n<li>Super-interfaces</li>\n<li>Signatures of exported methonds and fields</li>\n<li>Client interface of <em>direct</em> superclass</li>\n</ul>\n<h3 id=\"other-interfaces\">Other Interfaces</h3>\n<ul>\n<li>Subclass interface (i.e <code class=\"language-text\">protected</code>)</li>\n<li>Friend interface (<code class=\"language-text\">friend</code> in C++, default access in Java)</li>\n<li>Inner classes</li>\n<li>…</li>\n</ul>\n<h3 id=\"java-access-modifiers\">Java Access Modifiers</h3>\n<ul>\n<li><code class=\"language-text\">public</code>: client interface</li>\n<li><code class=\"language-text\">protected</code>: subclass and <em>friend</em> interface</li>\n<li>default access: friend interface</li>\n<li><code class=\"language-text\">private</code>: implementation</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>Modifier</th>\n<th>Class</th>\n<th>Package</th>\n<th>Subclass</th>\n<th>World</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">public</code></td>\n<td>Yes</td>\n<td>Yes</td>\n<td>Yes</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">protected</code></td>\n<td>Yes</td>\n<td>Yes</td>\n<td>Yes</td>\n<td>No</td>\n</tr>\n<tr>\n<td>’<em>default</em>’</td>\n<td>Yes</td>\n<td>Yes</td>\n<td>No</td>\n<td>No</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">private</code></td>\n<td>Yes</td>\n<td>No</td>\n<td>No</td>\n<td>No</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"safe-changes\">Safe Changes</h3>\n<ul>\n<li>Renaming of hidden elements</li>\n<li>Modification of hidden implementation (functionally needs to be preserved)</li>\n<li>Access modifiers specify what classes might be affected by a change</li>\n</ul>\n<h3 id=\"exchanging-implementation\">Exchanging Implementation</h3>\n<ul>\n<li>Behaviour needs to be preserved</li>\n<li>Exported fields limit modification\n<ul>\n<li>Use getters and setters</li>\n<li>Uniform access (Eiffel, Scala)</li>\n</ul>\n</li>\n<li>Modification is critical: Fragile baseclass problem!</li>\n<li>Object structures</li>\n</ul>\n<h3 id=\"bug-method-selection-in-java\">Bug: Method Selection in Java</h3>\n<ul>\n<li>\n<p>Bug was present in JSL1. It’s fixed now!</p>\n</li>\n<li>\n<p>Compile time:</p>\n<ol>\n<li>Determin static declaration (find the method in the receiver class, method can be inherited)</li>\n<li>Check accessibility</li>\n<li>Determine invocation mode (virtual / non-virtual)</li>\n</ol>\n</li>\n<li>\n<p>At run-time:\n4. Compute receiver reference\n5. Locate method to invoke (based on dynamic type of receiver object) that overwrites</p>\n</li>\n<li>\n<p>Rules for overriding</p>\n<ul>\n<li>Access modifier of overriding method must provide at least as much access as the overridden method</li>\n<li>default access → <code class=\"language-text\">protected</code> → <code class=\"language-text\">public</code></li>\n<li><code class=\"language-text\">private</code> methods can’t be overridden: Hiding</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"encapsulation\">Encapsulation</h2>\n<blockquote>\n<p>Encapsulation is used to guarantee that data and structural consistency by capsules with well defined interfaces.</p>\n</blockquote>\n<ul>\n<li>\n<p>Data consistency: i.e value is not negatice, …</p>\n</li>\n<li>\n<p>Structural consistency: i.e tree is balanced, list is doubly linked, …</p>\n</li>\n<li>\n<p>Concerns dynamic parts of code (execution)</p>\n</li>\n<li>\n<p>Context of a module can be changed but module behaves same</p>\n</li>\n</ul>\n<h3 id=\"levels-of-encapsulation\">Levels of Encapsulation</h3>\n<p>Capsules can be:</p>\n<ul>\n<li>Individual objects</li>\n<li>Object structures: i.e doubly-linked list</li>\n<li>A class (with all its objects): i.e all threads in Java</li>\n<li>All classes of a subtype hierarchy</li>\n<li>A package with all of its classes and their objects)</li>\n<li>Several packages</li>\n</ul>\n<p>Internal representation of capsule that needs to be proteced:</p>\n<ul>\n<li>invariant</li>\n<li>or history constraint</li>\n</ul>\n<p>Hiding fields are useful for:</p>\n<ul>\n<li>Information Hiding</li>\n<li>Encapsulation</li>\n</ul>\n<h3 id=\"achieving-consistency-of-objects\">Achieving Consistency of Objects</h3>\n<ol>\n<li>Apply information hiding wherever possible</li>\n<li>Make consistency criteria explicit\n<ul>\n<li>Contracts</li>\n<li>Informal documentation</li>\n</ul>\n</li>\n<li>Check interfaces (also subclass methods, i.e <code class=\"language-text\">protected</code>)\n<ul>\n<li>Make sure they preserve documented consistency criteria</li>\n</ul>\n</li>\n</ol>\n<!-- End of Slides 5 -->\n<h1 id=\"object-structures\">Object Structures</h1>\n<!-- Beginnning of Slides 6 -->\n<blockquote>\n<p>An object structure is a set of objects that are connected via references.</p>\n</blockquote>\n<h2 id=\"examples\">Examples</h2>\n<ul>\n<li>Array-Based Lists</li>\n<li>Doubly-Linked Lists (<code class=\"language-text\">java.util</code>)</li>\n</ul>\n<h2 id=\"aliasing\">Aliasing</h2>\n<ul>\n<li>\n<p>A reference to memory location</p>\n<ul>\n<li>Aliasing occures if more than one variable allows access to the same memory location</li>\n</ul>\n</li>\n<li>\n<p>Static/Dynamic Aliases</p>\n<ul>\n<li>Static alias: all involved variables are in the heap</li>\n<li>Dynamic aliasing: some involved variables are stack-allocated (others can be in the heap)</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"intended-aliasing\">Intended Aliasing</h3>\n<ul>\n<li>Efficiency\n<ul>\n<li>Objects need not to be copied, when passed or modified</li>\n</ul>\n</li>\n<li>Sharing\n<ul>\n<li>Share the same object between different places</li>\n<li>Consequence of objects identity</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"unintended-aliasing\">Unintended Aliasing</h3>\n<h4 id=\"capturing\">Capturing</h4>\n<ul>\n<li>Get a reference from outside and store it\n<ul>\n<li>Often in constructors that take reference arguments</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"leaking\">Leaking</h4>\n<ul>\n<li>\n<p>Passing a reference to an (internal) data structure to the outside</p>\n</li>\n<li>\n<p>More frequent then capturing</p>\n</li>\n</ul>\n<h4 id=\"problems-with-aliasing\">Problems with Aliasing</h4>\n<ul>\n<li>Aliases can be used to by-pass interface</li>\n<li>Interfaces and contracts remains unchanged but observable behaviour can change!</li>\n</ul>\n<h4 id=\"consistency-of-object-structures\">Consistency of Object Structures</h4>\n<ul>\n<li>Consistency of object structures debend on several fields (not only one)</li>\n<li>Checking invariance on beginning and end of method is not enough\n<ul>\n<li>State can be changed in between by an alias</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"other-problems-with-aliasing\">Other Problems with Aliasing</h4>\n<ul>\n<li>Synchronization in concurrent programs\n<ul>\n<li>Lock protects data structure</li>\n<li>Locking a reference dosen’t lock aliases</li>\n</ul>\n</li>\n<li>Distributed programming\n<ul>\n<li>i.e Remote Method Invocation</li>\n<li>References (intended aliases) are lost</li>\n</ul>\n</li>\n<li>Optimizations\n<ul>\n<li>i.e Inlining is not possible for aliased objects</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"alias-control-in-java\">Alias Control in Java</h3>\n<h4 id=\"linkedlist\"><code class=\"language-text\">LinkedList</code>:</h4>\n<ul>\n<li>All fields are <code class=\"language-text\">private</code></li>\n<li><code class=\"language-text\">Entry</code> is <em>private inner class</em> of <code class=\"language-text\">LinkedList</code>\n<ul>\n<li>References are not passed out</li>\n<li>Subclasses cannot manipulate or leak <code class=\"language-text\">Entry</code> objects</li>\n</ul>\n</li>\n<li><code class=\"language-text\">ListItr</code> is <em>private inner class</em> of <code class=\"language-text\">LinkedList</code>\n<ul>\n<li>Interface <code class=\"language-text\">ListIterator</code> provides controlled access to <code class=\"language-text\">ListItr</code> objects</li>\n<li><code class=\"language-text\">ListItr</code>objects are passed out in a controlled way</li>\n<li>Subclasses cannot manipulate or lead <code class=\"language-text\">ListItr</code> objects</li>\n</ul>\n</li>\n<li>Subclassing is restricted!</li>\n</ul>\n<h4 id=\"string\"><code class=\"language-text\">String</code></h4>\n<ul>\n<li>All fields are <code class=\"language-text\">private</code></li>\n<li>References to internal char-array are not passed out</li>\n<li>Subclassing is prohibited (<code class=\"language-text\">final</code>)</li>\n</ul>\n<!-- End Notes Week 9 -->\n<h2 id=\"readonly-types\">Readonly Types</h2>\n<!-- Beginning of Notes Week 10 -->\n<ul>\n<li>Restrict access to shared objects</li>\n<li>Common: grant read-only access</li>\n<li>Cloning can prevent aliasing in some cases (but is inefficient)</li>\n<li>The reference can be marked as readonly\n<ul>\n<li>The object itself is not readonly</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"requirements-for-readonly-access\">Requirements for Readonly Access</h3>\n<ul>\n<li>\n<p>Mutable objects</p>\n<ul>\n<li>Only some clients can mutate object</li>\n<li>Access restrictions apply to references (not whole objects)</li>\n</ul>\n</li>\n<li>\n<p>Prevent field updates, calls of mutating objects</p>\n</li>\n<li>\n<p>Transitivity</p>\n</li>\n<li>\n<p>Possible solution: wrap objects in readonly objects or use a readonly interface</p>\n<ul>\n<li>Not practical</li>\n<li>Not safe: no compiler checks, readwrite alias can still occur, …</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>Readonly access in C++ (<code class=\"language-text\">const</code>) is not transitive</p>\n</blockquote>\n<h3 id=\"pure-methods\">Pure Methods</h3>\n<p>Pure methods are side-effect free.</p>\n<ul>\n<li>Must not contain field updates</li>\n<li>Must not invoke non-pure methods</li>\n<li>Must not create objects (on heap)</li>\n<li>Can be only overridden by pure methods</li>\n<li>Stronger constraints than const methods in C++</li>\n</ul>\n<p>Pure methods are very restrictive:</p>\n<ol>\n<li>Not possible to get an iterator (which is created on heap) to iterate over collection</li>\n<li>Caches can’t be implemented</li>\n<li>Lazy initialization is not possible</li>\n</ol>\n<h3 id=\"readwrite-and-readonly-types\">Readwrite and Readonly Types</h3>\n<ul>\n<li>Concerns only reference type (object type is always mutable)</li>\n<li>Readwrite type: <code class=\"language-text\">T</code></li>\n<li>Readonly type: <code class=\"language-text\">readonly T</code></li>\n<li>Subtype relation: <code class=\"language-text\">T</code> &#x3C;: <code class=\"language-text\">readonly T</code></li>\n<li>Not same as relation between mutable and non-mutable types (which have no relation)</li>\n<li>Readonly is transitive</li>\n</ul>\n<h3 id=\"transitivity-of-readonly-types\">Transitivity of Readonly Types</h3>\n<p>The type of</p>\n<ul>\n<li>Field access</li>\n<li>Array access</li>\n<li>Method invocation</li>\n</ul>\n<p>is determined by type combinator: ►</p>\n<table>\n<thead>\n<tr>\n<th>►</th>\n<th>rw T</th>\n<th>ro T</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>rw S</td>\n<td>rw T</td>\n<td>ro T</td>\n</tr>\n<tr>\n<td>ro S</td>\n<td>ro T</td>\n<td>ro T</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"type-rules-readonly-access\">Type Rules: Readonly Access</h4>\n<p>Readonly types can’t be receiver of:</p>\n<ul>\n<li>Field update</li>\n<li>Array update</li>\n<li>Invocation of pure method</li>\n</ul>\n<p>Readonly types must not be cast to readwrite types.</p>\n<ul>\n<li>Leaking can be prevented</li>\n<li>Capturing can still occure</li>\n</ul>\n<h2 id=\"ownership-types\">Ownership Types</h2>\n<p>Prevents capturing.</p>\n<h3 id=\"object-topologies\">Object Topologies</h3>\n<p>Distinguish <em>internal</em> references from other references.</p>\n<h4 id=\"roles-in-object-structures\">Roles in Object Structures</h4>\n<ul>\n<li>Interface objects: used to access the structure</li>\n<li>Internal representation: must not be exposed to outside (clients)</li>\n<li><em>Arguments</em> of the object structure: must not be modified by the structure (i.e entries in a list)</li>\n</ul>\n<h4 id=\"ownership-model\">Ownership Model</h4>\n<ul>\n<li>Each object has one (or zero) owner</li>\n<li>An object belongs to the internal representation of the owner</li>\n<li>Ownership relation is acyclic (forrest of ownership trees)</li>\n<li>Context: all objects that have the same owner</li>\n<li>Ownership relation is <em>not</em> transitive</li>\n</ul>\n<p>Type Invariant:</p>\n<blockquote>\n<p>The <em>static</em> ownership information (declared in code) reflects the <em>run-time</em> ownership of the referenced object</p>\n</blockquote>\n<h4 id=\"ownership-types-1\">Ownership Types</h4>\n<ul>\n<li><strong>peer</strong>: in the same context, same owner as owner of <em>this</em></li>\n<li><strong>rep</strong>: references to objects owned by <em>this</em> (in the context of <em>this</em>)</li>\n<li><strong>any</strong>: in any context (I don’t care)</li>\n<li><strong>lost</strong>: specific owner but not known (I care but don’t know)</li>\n<li><strong>self</strong>: only for the <code class=\"language-text\">this</code> literal (special because ownership relative to <code class=\"language-text\">this</code>)</li>\n</ul>\n<p><strong>lost</strong> and <strong>self</strong> are internal (hidden) type modifiers. No keywords.</p>\n<p>Traversing hierarchy:</p>\n<ul>\n<li><strong>rep</strong>: go down in herarchy</li>\n<li><strong>peer</strong>: go across on same level in hierarchy</li>\n<li><strong>any</strong>: jump somewhere, could even be outside of hierarchy</li>\n</ul>\n<h4 id=\"type-safety\">Type Safety</h4>\n<ul>\n<li>RTTI contains:\n<ul>\n<li>The class of each object</li>\n<li>The <em>owner</em> of <em>each object</em></li>\n</ul>\n</li>\n<li>Type invariant:\n<ul>\n<li>static ownership reflects run-time owner</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p><em>any</em> and <em>lost</em> are extistential types.</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\">any <span class=\"token class-name\">T</span> o<span class=\"token punctuation\">;</span></code></pre></div>\n<p>There exitst an owner such that o ist an istance of T and has that owner.</p>\n<h4 id=\"subtyp-relation-between-ownership-types\">Subtyp Relation between Ownership Types</h4>\n<p><strong>rep</strong> types and <strong>peer</strong> types are subtypes of corresponsing <strong>any</strong> types.</p>\n<ul>\n<li><strong>rep</strong> T &#x3C;: <strong>any</strong> T</li>\n<li><strong>peer</strong> T &#x3C;: <strong>any</strong> T</li>\n</ul>\n<p>Casts:</p>\n<ul>\n<li><strong>any</strong> can be cast to <strong>rep</strong> or <strong>peer</strong> (with runtime checks)</li>\n</ul>\n<h4 id=\"viewpoint-adaption\">Viewpoint Adaption</h4>\n<ul>\n<li>Ownership relation is expressed relative to <em>this</em>.</li>\n<li>If <em>this</em> object (viewpoint) changes, the ownership changes.</li>\n<li>When creating an object the ownership has to be set\n<ul>\n<li><code class=\"language-text\">new rep Entry()</code></li>\n<li><code class=\"language-text\">new peer Entry()</code></li>\n<li><strong>any</strong> is not allowed for <code class=\"language-text\">new</code></li>\n<li>Ownership can’t be changed later</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>►</th>\n<th>peer T</th>\n<th>rep T</th>\n<th>any T</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>peer S</td>\n<td>peer T</td>\n<td>lost T</td>\n<td>any T</td>\n</tr>\n<tr>\n<td>rep S</td>\n<td>rep T</td>\n<td>lost T</td>\n<td>any T</td>\n</tr>\n<tr>\n<td>any S</td>\n<td>lost T</td>\n<td>lost T</td>\n<td>any T</td>\n</tr>\n<tr>\n<td>lost S</td>\n<td>lost T</td>\n<td>lost T</td>\n<td>any T</td>\n</tr>\n<tr>\n<td>self S</td>\n<td>peer T</td>\n<td>rep T</td>\n<td>any T</td>\n</tr>\n</tbody>\n</table>\n<p><img src=\"/47ca23b0e9a07de26d8529d1149e8567/coop_ownership_types_hierarchy.svg\" alt=\"Ownership Types Hierarchy\"></p>\n<h4 id=\"field-access-and-method-invocation-type-rules\">Field Access and Method Invocation (Type Rules)</h4>\n<p><span class=\"math math-inline\"><span class=\"katex\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>τ</mi><mo stretchy=\"false\">(</mo><mi>a</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\tau(a)</annotation></semantics></math></span></span>: Type of a</p>\n<p>Field <strong>Read</strong> or Method <strong>Parameters</strong>:</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\">v <span class=\"token operator\">=</span> e<span class=\"token punctuation\">.</span>f<span class=\"token punctuation\">;</span></code></pre></div>\n<p>Is correctly typed if:</p>\n<div class=\"math math-display\"><span class=\"katex\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>τ</mi><mo stretchy=\"false\">(</mo><mi>v</mi><mo stretchy=\"false\">)</mo><mo>:</mo><mo>></mo><mi>τ</mi><mo stretchy=\"false\">(</mo><mi>e</mi><mo stretchy=\"false\">)</mo><mo>▶</mo><mi>τ</mi><mo stretchy=\"false\">(</mo><mi>f</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\tau(v) :> \\tau(e) \\blacktriangleright \\tau(f)</annotation></semantics></math></span></div>\n<p>Field <strong>Write</strong> or Method <strong>Result</strong>:</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\">e<span class=\"token punctuation\">.</span>f <span class=\"token operator\">=</span> v<span class=\"token punctuation\">;</span></code></pre></div>\n<div class=\"math math-display\"><span class=\"katex\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>τ</mi><mo stretchy=\"false\">(</mo><mi>e</mi><mo stretchy=\"false\">)</mo><mo>▶</mo><mi>τ</mi><mo stretchy=\"false\">(</mo><mi>f</mi><mo stretchy=\"false\">)</mo><mo>:</mo><mo>></mo><mi>τ</mi><mo stretchy=\"false\">(</mo><mi>v</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\tau(e) \\blacktriangleright \\tau(f) :> \\tau(v)</annotation></semantics></math></span></div>\n<p>And</p>\n<div class=\"math math-display\"><span class=\"katex\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>τ</mi><mo stretchy=\"false\">(</mo><mi>e</mi><mo stretchy=\"false\">)</mo><mo>▶</mo><mi>τ</mi><mo stretchy=\"false\">(</mo><mi>f</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\tau(e) \\blacktriangleright \\tau(f)</annotation></semantics></math></span></div>\n<p>is <strong>not lost</strong>.</p>\n<h4 id=\"aliasing-1\">Aliasing</h4>\n<ul>\n<li><strong>rep</strong>: internal representation\n<ul>\n<li>no unwanted sharing</li>\n<li>leaking as <strong>rep</strong>: viewpoint-adaptation in client gets <strong>lost</strong></li>\n<li>method argument <strong>rep</strong></li>\n<li>capturing as <strong>rep</strong>: gets <strong>lost</strong>, can’t assign to <strong>lost</strong></li>\n</ul>\n</li>\n</ul>\n<p>Example:</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Person</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">private</span> rep <span class=\"token class-name\">Address</span> addr<span class=\"token punctuation\">;</span> <span class=\"token comment\">// part of internal representation</span>\n  <span class=\"token keyword\">public</span> rep <span class=\"token class-name\">Address</span> <span class=\"token function\">getAddr</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> addr<span class=\"token punctuation\">;</span> <span class=\"token comment\">// clients get lost-reference</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setAddr</span><span class=\"token punctuation\">(</span>rep <span class=\"token class-name\">Address</span> a<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    addr <span class=\"token operator\">=</span> a<span class=\"token punctuation\">;</span> <span class=\"token comment\">// cannot be called by clients (lost) only by this bject</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setAddr</span><span class=\"token punctuation\">(</span>any <span class=\"token class-name\">Address</span> a<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    addr <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> rep <span class=\"token class-name\">Address</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// cloning necessary, can't assign any to rep</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<!-- End of Notes Week 10 -->\n<!-- Beginning of Notes Week 11 -->\n<h2 id=\"owner-as-modifier\">Owner-as-Modifier</h2>\n<ul>\n<li>\n<p>Readonly Typesystem: leaking is safe (only readonly leaking)</p>\n</li>\n<li>\n<p>Ownership Typesystem: capturing is safe (declaring internal references as <strong>rep</strong>)</p>\n<ul>\n<li>leaking can happen only as <strong>any</strong> or <strong>lost</strong></li>\n</ul>\n</li>\n<li>\n<p>Combining both Typesystem</p>\n</li>\n<li>\n<p><strong>any</strong> and <strong>lost</strong>: Readonly</p>\n</li>\n</ul>\n<p>Additional enforced rules:</p>\n<ul>\n<li>Field write <code class=\"language-text\">e.f = v;</code> is valid <em>only</em> if <span class=\"math math-inline\"><span class=\"katex\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>τ</mi><mo stretchy=\"false\">(</mo><mi>e</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\tau(e)</annotation></semantics></math></span></span> is <strong>self</strong>, <strong>peer</strong> or <strong>rep</strong></li>\n<li>Method call <code class=\"language-text\">e.m(...);</code> is valid <em>only</em> if <span class=\"math math-inline\"><span class=\"katex\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>τ</mi><mo stretchy=\"false\">(</mo><mi>e</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\tau(e)</annotation></semantics></math></span></span> is <strong>self</strong>, <strong>peer</strong> or <strong>rep</strong>, or called method is <strong>pure</strong></li>\n</ul>\n<blockquote>\n<p>A method can modify directly at most all the objects that have the same owner as <code class=\"language-text\">this</code>. Everything further down in the hierarchy can only be changed indirectly (via method calls).</p>\n</blockquote>\n<ul>\n<li>\n<p>When debugging: if an object changes the changing method is going to be on the call stack</p>\n<ul>\n<li>Changing methods need to go through all the owners transitively</li>\n<li>Owner is like a <em>gate keeper</em> (interface object)</li>\n</ul>\n</li>\n<li>\n<p>Stronger concept for encapsulation than private-protected-public</p>\n</li>\n<li>\n<p>leaking only happens as readonly (‘something’ ► <strong>rep</strong>: <strong>lost</strong>)</p>\n</li>\n<li>\n<p>Standard (Java): default modifier would be <strong>peer</strong>, flat datastructures</p>\n</li>\n<li>\n<p>‘shared ownership’ is not possible. i.e List owns nodes and modifying Iterator would need readwrite access to nodes.</p>\n<ul>\n<li>List would need</li>\n</ul>\n</li>\n<li>\n<p>The system can be combined with Generics: <code class=\"language-text\">rep List&lt;peer Address></code></p>\n</li>\n<li>\n<p>Also possible: merge <em>entire contexts</em> to new owner. i.e concat two lists.</p>\n</li>\n</ul>\n<h3 id=\"achievements\">Achievements</h3>\n<ul>\n<li>Encapsulate whole object structures</li>\n<li>Can not be violated</li>\n<li>Subclassing is no restriction</li>\n<li>Invariants of object <em>o</em> can depend on:\n<ul>\n<li>Encapsulated fields of <em>o</em> (as usual)</li>\n<li>Fields of objects transitively owned by <em>o</em></li>\n</ul>\n</li>\n</ul>\n<!-- End of Slides 6 -->\n<!-- Beginning of Slides 7 -->\n<h1 id=\"initialization-and-null-references\">Initialization and Null-References</h1>\n<ul>\n<li>Main Usages of Null-References\n<ul>\n<li>Terminate recursion, list, …</li>\n<li>Initialization (i.e lazy initialization)</li>\n<li>‘Result not found’ as a return value of a function (absence of an object)</li>\n</ul>\n</li>\n<li>Most (80%) of all variables in an OOP programm are <em>non-null</em> after initalization</li>\n<li>Real need for null value is rare</li>\n<li>Theoretical type system:\n<ul>\n<li>Non-null tye: <code class=\"language-text\">T!</code> (references to <code class=\"language-text\">T</code>-Object)</li>\n<li>Possibly-null type: <code class=\"language-text\">T?</code> (references to <code class=\"language-text\">T</code>-Object plus <strong>null</strong>)</li>\n<li>Subtype relations (S &#x3C;: T)\n<ul>\n<li>S! &#x3C;: T!</li>\n<li>S? &#x3C;: T?</li>\n<li>T! &#x3C;: T?</li>\n<li>Dereferencing only possible with non-null type (<code class=\"language-text\">T!</code>)</li>\n<li>Possible casts:\n<ul>\n<li>Implicit: From non-null to possibly-null (<code class=\"language-text\">T! nn = ...; T? pn = nn;</code>)</li>\n<li>Downcasts (explicit) are possible but need <em>run-time</em> checks (<code class=\"language-text\">T? pn = ...; T! nn = (T!)pn;</code> Shortcut for <code class=\"language-text\">(T!)</code>: <code class=\"language-text\">(!)</code>)</li>\n<li>Additional type rules (compared to Java): Expressions whose value gets dereferenced need <em>non-null</em> type\n<ul>\n<li>Receiver of: field access, array access, method call</li>\n<li>Expressions of a <code class=\"language-text\">throw</code> statement</li>\n</ul>\n</li>\n<li>Dataflow Analysis\n<ul>\n<li>Check if a value at a given position in code can or can’t be <em>null</em></li>\n<li>Tracks values of local variables but not of objects on the <em>heap</em>\n<ul>\n<li>Tracking heap locations is non-moduler</li>\n<li>Other threads could modify heap locations</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"object-initialization\">Object Initialization</h2>\n<ul>\n<li>All fields are initialized to null (Java, C#, …)</li>\n<li>Invariant of non-null types is violated at beginning of constructor (it’s initialized to <code class=\"language-text\">null</code> by default)\n<ul>\n<li>Make sure that all non-null fields are initialized when constructor terminates\n<ul>\n<li>Similar to <em>Definite Assignment Rule</em> that check that local variables are assigned before first use (Java, C#)</li>\n<li>Needes checks:\n<ul>\n<li>Dereferces</li>\n<li>non-null fields have non-null types</li>\n<li>non-null arguments are passed non-null method parameters</li>\n</ul>\n</li>\n<li>Not possible to check for all cases: <em>escaping the constructor</em>\n<ul>\n<li>The simple <em>Definite Assignement Rule</em> is only sound if <em>partly-initialized object do not escape</em> from constructor</li>\n<li>Overly restrictive: on <em>partly-initialzed objects</em>\n<ul>\n<li>Dont call methods</li>\n<li>Don’t pass as argument to methods</li>\n<li>Dont’s store in fields or an array</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Better type-system: track initialization (construction types)\n<ul>\n<li>Initialization Phases (3 types per class/interface)\n<ul>\n<li><em>free type</em>: objects under construction (free to violate invariants, free to have null in non-null variables)</li>\n<li><em>committed type</em>: object construction is completed (type of object is chaged at run-time when object is fully constructed)</li>\n<li><em>unclassified type</em>: super-type of <em>free type</em> and <em>committed type</em></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>Type Invariant:</p>\n<blockquote>\n<p>An object is initialized if all fields have non-null values (transitively).</p>\n</blockquote>\n<p>There could also be other invariants that have to hold after object is initialized, but can be broken before the object is fully initialized.</p>\n<!-- End Notes Week 11 -->\n<!-- Beginning Notes Week 12 -->\n<h2 id=\"type-rules\">Type Rules</h2>\n<ul>\n<li>Most type rules of Java remain unchanged</li>\n<li>Additional requirement: dereferencing needs a non-null type\n<ul>\n<li>Receiver of field access</li>\n<li>Receiver of array access</li>\n<li>Receiver of method call</li>\n<li>Expression of a <code class=\"language-text\">throw</code> statement</li>\n</ul>\n</li>\n<li>Dereferencing of a non-null type can be checked statically (compile time)</li>\n<li>Escaping constructor is an issue</li>\n<li>Combining non-null type system with construction types\n<ul>\n<li>6 types</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>non-null</th>\n<th>possibly-null</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>comitted</td>\n<td><code class=\"language-text\">T!</code></td>\n<td><code class=\"language-text\">T?</code></td>\n</tr>\n<tr>\n<td>free</td>\n<td><code class=\"language-text\">free T!</code></td>\n<td><code class=\"language-text\">free T?</code></td>\n</tr>\n<tr>\n<td>unclassified</td>\n<td><code class=\"language-text\">unc T!</code></td>\n<td><code class=\"language-text\">unc T?</code></td>\n</tr>\n</tbody>\n</table>\n<p>No downcasts from unclassified to free or committed (no reasonable run-time checks).</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 270px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/3d2da676d55dcec81f2e69837d0cf883/01bf6/coop_non-null_and_construction_types.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 81.64556962025317%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAAAsTAAALEwEAmpwYAAABpUlEQVQ4y4WTWY/CMAyE8///FO9IvCFEOarSlptytBzl9Oqz5G7JsnSkqFFjjydjx8kXvF4v/e73e1mtVrJer2W5XOqaz+ey2Wx0fz6fq3jnJ9e/tofMMBgMJEkSJQKXy0V2u90voSXaej6fFZEBZbPZTEajkbTbbUnTVMIwVIUoPRwOfxX6gPh4PEpRFJJlmV57Op3KeDxWAkj5T1wd7na7qWQSWSghKY5jyfNc1UFGMmqIIQdATLwVvl6v4pCNqfiEP0EQ6AFFCNxut3K/32U4HOo/yMw/crEAK7CAog4iI0QZFR+PhyZbdyFcLBaVCvYA4l6vVzWJWEeXUFGWpSpstVoagF+ooRjqJpOJ7olFOSCHuH6/r8U4d34j8O10Ouk4QBJFkTYAteYd4Bb8g7w+FW9jYyCQ6niC8ZCaLQASzrh+fY6rsfGH2mYPr+zaKKYJFLO58x9A40vBH/OMkUGhqfKJbO8+vV17MSzMxtdvqt4G+xMhJDSC7nU6Hel2u3pdfKsT+mT/EqII3/CQoaXrnOHrJ1WNhHQYMq7Jwkf8g7iJ8Aegf9Tfizs/4wAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Construction types hierarchy\"\n        title=\"Construction types hierarchy\"\n        src=\"/static/3d2da676d55dcec81f2e69837d0cf883/01bf6/coop_non-null_and_construction_types.png\"\n        srcset=\"/static/3d2da676d55dcec81f2e69837d0cf883/c26ae/coop_non-null_and_construction_types.png 158w,\n/static/3d2da676d55dcec81f2e69837d0cf883/01bf6/coop_non-null_and_construction_types.png 270w\"\n        sizes=\"(max-width: 270px) 100vw, 270px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2 id=\"local-initialization\">Local Initialization</h2>\n<ul>\n<li>An object is locally initialized: all non-null fields have non-null values</li>\n<li>Static type <em>committed</em>: locally initialized at run-time</li>\n</ul>\n<p>Field access:</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\">e<span class=\"token punctuation\">.</span>f</code></pre></div>\n<table>\n<thead>\n<tr>\n<th>Field access</th>\n<th>f: <code class=\"language-text\">!</code></th>\n<th>f: <code class=\"language-text\">?</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>e: <code class=\"language-text\">commited</code></td>\n<td><code class=\"language-text\">!</code></td>\n<td><code class=\"language-text\">?</code></td>\n</tr>\n<tr>\n<td>e: <code class=\"language-text\">free</code></td>\n<td><code class=\"language-text\">?</code></td>\n<td><code class=\"language-text\">?</code></td>\n</tr>\n<tr>\n<td>e: <code class=\"language-text\">unc</code></td>\n<td><code class=\"language-text\">?</code></td>\n<td><code class=\"language-text\">?</code></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"transitive-initialization\">Transitive Initialization</h2>\n<ul>\n<li><em>Committed</em> has to be transitive</li>\n<li>An object is <em>transitively initialized</em> if all reachable objecs are <em>localy initialized</em></li>\n<li>static type <em>committed</em>: transitively initialized at run-time</li>\n</ul>\n<h2 id=\"cyclic-structures\">Cyclic Structures</h2>\n<ul>\n<li>In initialization code (i.e constructor) it’s allowed to assign <em>committed</em> types to <strong>fields</strong> of  <em>free</em> types</li>\n</ul>\n<h2 id=\"type-rules-1\">Type Rules</h2>\n<ul>\n<li>Field declaration has no consturction-type modifier\n<ul>\n<li>non-null (<code class=\"language-text\">!</code>) or possibly-null (<code class=\"language-text\">?</code>) modifiers are possible</li>\n<li>It’s determined if it’s <em>free</em> or <em>committed</em> when dereferencing (<code class=\"language-text\">e.f</code>)</li>\n<li>Field declaration is the only place in a programm that has not construction-type modifier</li>\n</ul>\n</li>\n<li><em>committed</em> is transitive!</li>\n<li>It’s not allowed to have a <em>committed</em> and a <em>free</em> reference to the same object (no cross-type aliases)\n<ul>\n<li>The <em>free</em> reference could assign a pointer in the object to an uninitialized field</li>\n</ul>\n</li>\n<li>It’s critical when an reference changes from <em>free</em> to <em>committed</em></li>\n</ul>\n<h3 id=\"field-write\">Field Write</h3>\n<p>A field write</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\">a<span class=\"token punctuation\">.</span>f <span class=\"token operator\">=</span> b</code></pre></div>\n<p>is well-typed if</p>\n<ul>\n<li><code class=\"language-text\">a</code> and <code class=\"language-text\">b</code> are well-typed</li>\n<li><code class=\"language-text\">a</code>’s type is a non-null type (<code class=\"language-text\">!</code>)</li>\n<li><code class=\"language-text\">b</code>’s class and non-null type conforms to <code class=\"language-text\">a.f</code></li>\n<li>**<code class=\"language-text\">a</code>’s type is <em>free</em> or <code class=\"language-text\">b</code>’s type is <em>committed</em> **</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>type of <code class=\"language-text\">a</code> \\ type of <code class=\"language-text\">b</code></th>\n<th>committed</th>\n<th>free</th>\n<th>unc</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>committed</td>\n<td>✓</td>\n<td>✘</td>\n<td>✘</td>\n</tr>\n<tr>\n<td>free</td>\n<td>✓</td>\n<td>✓</td>\n<td>✓</td>\n</tr>\n<tr>\n<td>unc</td>\n<td>✓</td>\n<td>✘</td>\n<td>✘</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"field-read\">Field Read</h3>\n<ul>\n<li>A field read <code class=\"language-text\">e.f</code>is well-typed if:\n<ul>\n<li><code class=\"language-text\">e</code> is well-typed</li>\n<li><code class=\"language-text\">e</code>’s type is a non-null type (<code class=\"language-text\">!</code>)</li>\n<li>Field (<code class=\"language-text\">f</code>) has no construction-type modifier</li>\n</ul>\n</li>\n</ul>\n<p>The type of <code class=\"language-text\">e.f</code> is:</p>\n<table>\n<thead>\n<tr>\n<th>type of e \\ type of f</th>\n<th><code class=\"language-text\">T!</code></th>\n<th><code class=\"language-text\">T?</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">S!</code></td>\n<td><code class=\"language-text\">T!</code></td>\n<td><code class=\"language-text\">T?</code></td>\n</tr>\n<tr>\n<td><code class=\"language-text\">free S!</code></td>\n<td><code class=\"language-text\">unc T?</code></td>\n<td><code class=\"language-text\">unc T?</code></td>\n</tr>\n<tr>\n<td><code class=\"language-text\">unc S!</code></td>\n<td><code class=\"language-text\">unc T?</code></td>\n<td><code class=\"language-text\">unc T?</code></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"consturctors\">Consturctors</h3>\n<ul>\n<li>Constructor signatures: each parameter has declared construction-type (default: <em>committed</em>) and null-ness type</li>\n<li><code class=\"language-text\">this</code> in cunstruction has implicitly: <em>free non-null</em></li>\n<li>Definite assignment check for complete constructor</li>\n<li>Constructors are <em>free</em> by default</li>\n<li>The most permessive type for <em>arguments in a constructor</em> declaration is <em>unc</em>\n<ul>\n<li>This should be chosen if possible</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"method-calls\">Method Calls</h3>\n<ul>\n<li>Method signatures: each parameter has declared construction-type (and null-ness type)</li>\n<li>Method signatures can contain construction-type for <code class=\"language-text\">this</code></li>\n</ul>\n<p>Construction-type for <code class=\"language-text\">this</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">String</span><span class=\"token operator\">!</span> free <span class=\"token function\">getId</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token operator\">!</span> n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>Overriding requires usual co- and contravariant rules\n<ul>\n<li>The receiver (<code class=\"language-text\">this</code>) counts as parameter</li>\n<li>Method arguments should not be declared as <em>unclassified</em> if possible\n<ul>\n<li>otherwise overriding methods need to cope with <em>unclassified</em> too</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"object-construction\">Object Construction</h3>\n<ul>\n<li>At the end of a constructor the object is not nessecary fully initialized (i.e constructors of deriving classes are not run yet)</li>\n<li>End of a <code class=\"language-text\">new</code> expression: constructed object might not yet be fully constructed</li>\n<li><code class=\"language-text\">new</code> expressions can have only references to committed objects outside of the <code class=\"language-text\">new</code> expression\n<ul>\n<li>committed reference to the <code class=\"language-text\">new</code> expression is not possible\n<ul>\n<li><code class=\"language-text\">new</code> not yet finished (not <em>committed</em>, <em>free</em>)</li>\n<li>But committed objects can’t have pointers to <em>free</em></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Nested <code class=\"language-text\">new</code> expression:\n<ul>\n<li>if the ‘inner’ <code class=\"language-text\">new</code> expression is fully (transitively) initialized reference <em>to</em> and <em>from</em> the outside</li>\n<li>the ‘outer’ <code class=\"language-text\">new</code> expression can point to the ‘inner’ <code class=\"language-text\">new</code> expression</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"new-expression\"><code class=\"language-text\">new</code> Expression</h4>\n<blockquote>\n<p>After ‘outer’ <code class=\"language-text\">new</code> expression (only committed arguments) finishes all ‘inner’ <code class=\"language-text\">new</code> expressions have references to locally initialized objects.\nAll references inside the ‘outer’ <code class=\"language-text\">new</code> expression point to transitively initialized objects.</p>\n</blockquote>\n<ul>\n<li>The type of a <code class=\"language-text\">new</code> expression is <em>committed</em> if the static types of all arguments of the constuctor are <em>committed</em>\n<ul>\n<li>Otherwise it’s <em>free</em></li>\n<li>It’s not relevant what the declared types of the constructor arguments are! It depends on the <code class=\"language-text\">new</code> expression</li>\n</ul>\n</li>\n<li>It’s almost not possible to create uninitialized objects</li>\n</ul>\n<h3 id=\"lazy-initialization\">Lazy Initialization</h3>\n<ul>\n<li>Access lazy initialized field always through getter method</li>\n</ul>\n<p>i.e</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Demo</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">private</span> <span class=\"token class-name\">Vector</span><span class=\"token operator\">?</span> data<span class=\"token punctuation\">;</span> <span class=\"token comment\">// possibly-null</span>\n  <span class=\"token keyword\">public</span> <span class=\"token class-name\">Vector</span><span class=\"token operator\">!</span> <span class=\"token function\">getData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">// getter guarantees for non-null</span>\n    <span class=\"token class-name\">Vectror</span><span class=\"token operator\">?</span> d <span class=\"token operator\">=</span> data<span class=\"token punctuation\">;</span> <span class=\"token comment\">// needed for data flow analysis</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>d <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      d <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Vector</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> data <span class=\"token operator\">=</span> d<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> d<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2 id=\"arrays\">Arrays</h2>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token comment\">// Elements</span>\n<span class=\"token comment\">//    |</span>\n<span class=\"token comment\">//    v</span>\n<span class=\"token class-name\">Person</span><span class=\"token operator\">!</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token operator\">!</span> a<span class=\"token punctuation\">;</span> <span class=\"token comment\">// Non-null array with non-null elements</span>\n<span class=\"token class-name\">Person</span><span class=\"token operator\">?</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token operator\">!</span> b<span class=\"token punctuation\">;</span> <span class=\"token comment\">// Non-null array with possibly-null elements</span>\n<span class=\"token class-name\">Person</span><span class=\"token operator\">!</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token operator\">?</span> c<span class=\"token punctuation\">;</span> <span class=\"token comment\">// Possibly-null array with non-null elements</span>\n<span class=\"token class-name\">Person</span><span class=\"token operator\">?</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token operator\">?</span> d<span class=\"token punctuation\">;</span> <span class=\"token comment\">// Possibly-null array with possibly-null elements (default in Java)</span>\n<span class=\"token comment\">//        ^</span>\n<span class=\"token comment\">//        |</span>\n<span class=\"token comment\">//      Array</span></code></pre></div>\n<ul>\n<li>Arrays have no constructors</li>\n<li>Problem: Array initialization is often done with loops\n<ul>\n<li>Definite assignment cannot be checked by compiler</li>\n</ul>\n</li>\n<li>Possible solutions:\n<ul>\n<li>Array initializers (<code class=\"language-text\">String! []! s = {\"Array\", \"of\", \"non-null\", \"Strings\"};</code>)</li>\n<li>Eiffel: pre-filling array (default objects not better than <code class=\"language-text\">null</code>)</li>\n<li>Run time assert provided by programmer (Spec#)\n<ul>\n<li><code class=\"language-text\">NonNullType.AssertInitialized(arr);</code> (run time assert function)</li>\n<li>Only committed elements can be stored in array</li>\n<li>Data flow analysis knows semantic of run time assert function</li>\n<li>Run time assert function changes type from <strong>free</strong> to <strong>committed</strong></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"summary\">Summary</h2>\n<ul>\n<li>Can be combined with Generics</li>\n<li>Invariant: non-nullness</li>\n<li>Avoid calling virtual methods on this in uninitialized objects (constructors, init methods)</li>\n<li>Don’t let escape uninitialized objects</li>\n<li>At end of constructor: object might not yet be constructed (i.e subclass constructors)</li>\n</ul>\n<!-- End of Notes Week 12 -->\n<!-- Beginning of Notes Week 13 -->\n<h2 id=\"initialization-of-global-data\">Initialization of Global Data</h2>\n<ul>\n<li>OO-Programs have also global data</li>\n<li>i.e Flightweight-Pattern, Singleton, Caches…</li>\n</ul>\n<h3 id=\"requirements\">Requirements</h3>\n<ul>\n<li>Must be initialized before first use (non-nullness)</li>\n<li>Handle mutual dependencies</li>\n<li>Lazy initialization</li>\n</ul>\n<h3 id=\"c\">C++</h3>\n<ul>\n<li>Global vars can have initializers</li>\n<li>Initializers are executed before <code class=\"language-text\">main</code> function\n<ul>\n<li>Implicitely called by run-time system</li>\n<li>No support for lazy initialization</li>\n</ul>\n</li>\n<li>Order of execution as in apearance in code</li>\n<li>No mechanism for dependancies (has to be donne by programmer)</li>\n</ul>\n<h3 id=\"java-similar-in-c\">Java (similar in C#)</h3>\n<ul>\n<li>Static initializer for static fields</li>\n<li>Lazy initialized</li>\n<li>No mechanism for mutual dependencies (call to not initialized reference possible)</li>\n<li>Static initializer can have side effects (no modular reasoning about initialization)</li>\n</ul>\n<h3 id=\"scala\">Scala</h3>\n<ul>\n<li>Language support for singletons</li>\n<li>Singletons can extend classes and traits but <em>can’t be specialized</em></li>\n<li>Internally translated to Java initialization</li>\n</ul>\n<h3 id=\"summary-1\">Summary</h3>\n<ul>\n<li>No solution really guarantees that global data is initialized before use</li>\n<li>No solution handles dependancies</li>\n<li>Carefull with global data (as programmer)!</li>\n</ul>\n<!-- End of Slides 7 -->\n<!-- Beginning of Slides 8 -->\n<h1 id=\"reflections\">Reflections</h1>\n<ul>\n<li>Program can observe and modify its structure and behavioral at run-time</li>\n<li>Simples form: RTTI (i.e for casting)</li>\n</ul>\n<h2 id=\"introspection\">Introspection</h2>\n<ul>\n<li>Get methods, fields… from classes (or individual objects)</li>\n<li>Checks are done at run-time instead of compile-time (exceptions)\n<ul>\n<li>Type checking</li>\n<li>Accessibility checks</li>\n</ul>\n</li>\n<li>Accessibity / information hiding can be weakend (security issue)</li>\n<li>Helpful for debugging</li>\n<li>JUnit’s test driver works with introspection</li>\n<li>Visitor pattern is much simpler with introspection</li>\n<li>Reflection API defines (and throws) <em>checked exceptions</em>\n<ul>\n<li>If underlying code (i.e throws an exception it is transformed into a <em>unchecked exception</em></li>\n</ul>\n</li>\n</ul>\n<p>Example:</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token class-name\">T</span> <span class=\"token function\">newInstance</span><span class=\"token punctuation\">(</span> <span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">InstantiationException</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">IllegalAccessException</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>If the constructor called internally by <code class=\"language-text\">newInstance</code> throws an exception (even a checked exception)\nit gets swalowed and rethrown as an unchecked exception.</p>\n<ul>\n<li>Visitor Pattern (Double Invocation) can be implemented much simpler with reflections\n<ul>\n<li>Second dynamic dispatch is implemented via reflection</li>\n<li><code class=\"language-text\">accept</code> methods in element classes</li>\n<li>Flexible</li>\n<li>Not statically safe: error handling code needed</li>\n<li>Slower than ‘traditional’ implementation</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"reflective-code-generation\">Reflective Code Generation</h2>\n<p>Examples:</p>\n<ul>\n<li>Java class loading</li>\n<li>Expression tree in C#\n<ul>\n<li>Represents Abstract Syntax Tree of C#</li>\n<li>AST can be created like any other data structure at run-time</li>\n<li>Can be compiled at run-time with <code class=\"language-text\">Compile</code> method</li>\n<li>Generation and compilation of code at run-time is expensive but pays if generated code is called often</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"dynamic-code-manipulation\">Dynamic Code Manipulation</h2>\n<ul>\n<li>Usually only available in dynamically typed languages (Python, Lisp…)</li>\n<li>Makes code difficult to understand</li>\n</ul>\n<h2 id=\"summary-2\">Summary</h2>\n<ul>\n<li>Very flexible (plug-ins)</li>\n<li>Serialization / persistance</li>\n<li>Design Patterns</li>\n<li>Dynamic code generation</li>\n<li>Not staticially safe!</li>\n<li>Information hiding can be compromized</li>\n<li>Hard to understand and debug</li>\n<li>Performance can be wery bad</li>\n</ul>\n<p>Reflection and Typechecking:</p>\n<table>\n<thead>\n<tr>\n<th>Degree of Reflection</th>\n<th>Type Checking</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Introspection</td>\n<td>Code can be checked once, when compiled</td>\n</tr>\n<tr>\n<td>Reflective Code Generation</td>\n<td>Code can be checked once, when generated</td>\n</tr>\n<tr>\n<td>Dynamic Code Manipulation</td>\n<td>Requires typically dynamic type checking</td>\n</tr>\n</tbody>\n</table>\n<!-- End of Slides 8 -->\n<!-- End of Notes Week 13 -->\n<!-- End of Course! -->","frontmatter":{"title":"Concepts of Object Oriented Programming","tags":["C++","Python","OOP","ETH"],"category":"Programming"},"headings":[{"depth":1,"value":"Core Requirements to OOP Languages"},{"depth":1,"value":"The Object Model"},{"depth":2,"value":"Interfaces and Encapsulation"},{"depth":2,"value":"Classification and Polymorphism"},{"depth":3,"value":"Classification"},{"depth":3,"value":"Polymorphism"},{"depth":4,"value":"Subtype Polymorphism"},{"depth":4,"value":"Parametric Polymorphism"},{"depth":4,"value":"Method Overloading"},{"depth":3,"value":"Spezialization"},{"depth":1,"value":"Types and Subtyping"},{"depth":2,"value":"Types"},{"depth":3,"value":"Weak and Strong Type Systems"},{"depth":4,"value":"Untyped Languages"},{"depth":4,"value":"Weakly Typed Languages"},{"depth":4,"value":"Strongly Typed Languages"},{"depth":3,"value":"Nominal and Structural Types"},{"depth":4,"value":"Nominal Types"},{"depth":4,"value":"Structural Types"},{"depth":3,"value":"Type Checking"},{"depth":4,"value":"Static Type Checking"},{"depth":4,"value":"Dynamic Type Checking"},{"depth":3,"value":"Overview of Type Systems in OO-Languages"},{"depth":2,"value":"Subtyping"},{"depth":3,"value":"Variance (Covariance, Contravariance and Invariance)"},{"depth":4,"value":"Covariance"},{"depth":4,"value":"Contravariance"},{"depth":4,"value":"Variance for OOP"},{"depth":3,"value":"Behavioral Subtyping (Contracts)"},{"depth":4,"value":"Subtyping and Contracs"},{"depth":4,"value":"Specification Inheritance (Inherit Contracts from Subtypes)"},{"depth":3,"value":"Types as Contracts"},{"depth":2,"value":"Inheritance"},{"depth":3,"value":"Difference between inheritance and subtyping"},{"depth":2,"value":"Aggregation vs. Private Inheritance (C++)"},{"depth":2,"value":"Static and Dynamic Method Binding"},{"depth":3,"value":"Static Method binding in Java"},{"depth":2,"value":"Rules for proper Subclassing"},{"depth":1,"value":"Binary Methods"},{"depth":1,"value":"Multiple Inheritance"},{"depth":2,"value":"Problems with multiple inheritance"},{"depth":1,"value":"Mixins and Traits"},{"depth":1,"value":"Parametric Polymorphism"},{"depth":2,"value":"Java, C#, …"},{"depth":3,"value":"Wildcards"},{"depth":2,"value":"C++ Templates"},{"depth":1,"value":"Information Hiding and Encapsulation"},{"depth":2,"value":"Information Hiding"},{"depth":3,"value":"Client Interface of a Class"},{"depth":3,"value":"Other Interfaces"},{"depth":3,"value":"Java Access Modifiers"},{"depth":3,"value":"Safe Changes"},{"depth":3,"value":"Exchanging Implementation"},{"depth":3,"value":"Bug: Method Selection in Java"},{"depth":2,"value":"Encapsulation"},{"depth":3,"value":"Levels of Encapsulation"},{"depth":3,"value":"Achieving Consistency of Objects"},{"depth":1,"value":"Object Structures"},{"depth":2,"value":"Examples"},{"depth":2,"value":"Aliasing"},{"depth":3,"value":"Intended Aliasing"},{"depth":3,"value":"Unintended Aliasing"},{"depth":4,"value":"Capturing"},{"depth":4,"value":"Leaking"},{"depth":4,"value":"Problems with Aliasing"},{"depth":4,"value":"Consistency of Object Structures"},{"depth":4,"value":"Other Problems with Aliasing"},{"depth":3,"value":"Alias Control in Java"},{"depth":4,"value":"<code class=\"language-text\">LinkedList</code>:"},{"depth":4,"value":"<code class=\"language-text\">String</code>"},{"depth":2,"value":"Readonly Types"},{"depth":3,"value":"Requirements for Readonly Access"},{"depth":3,"value":"Pure Methods"},{"depth":3,"value":"Readwrite and Readonly Types"},{"depth":3,"value":"Transitivity of Readonly Types"},{"depth":4,"value":"Type Rules: Readonly Access"},{"depth":2,"value":"Ownership Types"},{"depth":3,"value":"Object Topologies"},{"depth":4,"value":"Roles in Object Structures"},{"depth":4,"value":"Ownership Model"},{"depth":4,"value":"Ownership Types"},{"depth":4,"value":"Type Safety"},{"depth":4,"value":"Subtyp Relation between Ownership Types"},{"depth":4,"value":"Viewpoint Adaption"},{"depth":4,"value":"Field Access and Method Invocation (Type Rules)"},{"depth":4,"value":"Aliasing"},{"depth":2,"value":"Owner-as-Modifier"},{"depth":3,"value":"Achievements"},{"depth":1,"value":"Initialization and Null-References"},{"depth":2,"value":"Object Initialization"},{"depth":2,"value":"Type Rules"},{"depth":2,"value":"Local Initialization"},{"depth":2,"value":"Transitive Initialization"},{"depth":2,"value":"Cyclic Structures"},{"depth":2,"value":"Type Rules"},{"depth":3,"value":"Field Write"},{"depth":3,"value":"Field Read"},{"depth":3,"value":"Consturctors"},{"depth":3,"value":"Method Calls"},{"depth":3,"value":"Object Construction"},{"depth":4,"value":"<code class=\"language-text\">new</code> Expression"},{"depth":3,"value":"Lazy Initialization"},{"depth":2,"value":"Arrays"},{"depth":2,"value":"Summary"},{"depth":2,"value":"Initialization of Global Data"},{"depth":3,"value":"Requirements"},{"depth":3,"value":"C++"},{"depth":3,"value":"Java (similar in C#)"},{"depth":3,"value":"Scala"},{"depth":3,"value":"Summary"},{"depth":1,"value":"Reflections"},{"depth":2,"value":"Introspection"},{"depth":2,"value":"Reflective Code Generation"},{"depth":2,"value":"Dynamic Code Manipulation"},{"depth":2,"value":"Summary"}]}},"pageContext":{"id":"d01f61f5-7e70-563e-8b2a-7b5bee0243f6","previousPost":{"title":"Arrays in C and C++","slug":"/blog/arrays_c_cpp"},"nextPost":{"title":"Object File Formats","slug":"/blog/object_file_formats"},"dates":{"created":1438111438,"modified":1647509701}}},
    "staticQueryHashes": []}