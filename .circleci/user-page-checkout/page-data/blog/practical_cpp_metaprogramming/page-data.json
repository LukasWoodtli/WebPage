{
    "componentChunkName": "component---src-templates-blog-post-tsx",
    "path": "/blog/practical_cpp_metaprogramming",
    "result": {"data":{"site":{"siteMetadata":{"title":"My personal Website"}},"markdownRemark":{"id":"aa706932-8843-51f4-852a-d53628010d99","excerpt":"Notes taken from: Practical C++ Metaprogramming\nEdouard Alligand and Joel Falcou\nO’Reilly Media, Inc. My repository with examples on Github Chapter…","html":"<p>Notes taken from:</p>\n<p>Practical C++ Metaprogramming\nEdouard Alligand and Joel Falcou\nO’Reilly Media, Inc.</p>\n<p>My repository with examples on <a href=\"https://github.com/LukasWoodtli/PracticalCppMetaprogramming\">Github</a></p>\n<h1 id=\"chapter-1-introduction\">Chapter 1. Introduction</h1>\n<h2 id=\"the-early-history-of-metaprogramming\">The Early History of Metaprogramming</h2>\n<p><em>“LISP macros were able to be used to extend the languages from within.”</em></p>\n<p><em>“[In C/C++] An X-macro is, in fact, a header file containing a list of similar macro invocations—often called the components—which can be included multiple times. Each inclusion is prefixed by the redefinition of said macro to generate different code fragments for the same list of components.”</em></p>\n<h2 id=\"enter-c-templates\">Enter C++ Templates</h2>\n<p><em>“It was quickly discovered that by supporting partial specialization, compile-time equivalents of recursion or conditional statements were feasible.”</em></p>\n<p><em>“We could turn templates into a very crude and syntactically impractical functional language, which [is] Turing-complete.”</em></p>\n<p><em>“Applications of C++ template metaprogramming includes the following:</em></p>\n<ul>\n<li><em>Complex constant computations</em></li>\n<li><em>Programmatic type constructions</em></li>\n<li><em>Code fragment generation and replication”</em></li>\n</ul>\n<p><em>“Those applications are usually backed up by some libraries, like Boost.MPL or Boost.Fusion, and a set of patterns including tag dispatching, recursive inheritance, and SFINAE.”</em></p>\n<h1 id=\"chapter-2-c-metaprogramming-in-practice\">Chapter 2. C++ Metaprogramming in Practice</h1>\n<h2 id=\"the-stdtuple-pattern\">The <code class=\"language-text\">std::tuple&lt;></code> pattern</h2>\n<p><em>\"\"return a bunch of otherwise unrelated stuff.” This is a common pattern in modern C++”</em></p>\n<h2 id=\"returning-auto\">Returning auto`</h2>\n<p><em>“In template metaprogramming, there is no iterative construct.”</em></p>\n<p><em>“You can, however, use recursion to apply a callable on every member of the tuple.”</em></p>\n<p><em>“Whenever you can, you should use the <code class=\"language-text\">...</code> operator to apply a callable to every member of a list. This is faster, it doesn’t generate all the unneeded intermediate types, and the code is often more concise.”</em></p>\n<p><code class=\"language-text\">std :: index_sequence</code>: <em>“The trick is to create an index sequence - whose sole purpose is to give us an index on which to apply the <code class=\"language-text\">...</code> operator - of the right size. This is done as follows:”</em></p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">static</span> <span class=\"token keyword\">const</span> std<span class=\"token double-colon punctuation\">::</span>size_t params_count <span class=\"token operator\">=</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">(</span>Params<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nstd<span class=\"token double-colon punctuation\">::</span><span class=\"token generic-function\"><span class=\"token function\">make_index_sequence</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span>params_count<span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><em>“At compile time, when you need to know how many elements you have in your list, you use sizeof…().”</em></p>\n<h1 id=\"chapter-3-c-metaprogramming-and-application-design\">Chapter 3. C++ Metaprogramming and Application Design</h1>\n<h1 id=\"meta-axiom-1\">Meta-Axiom #1</h1>\n<p><em>“Types are first-class values inside compile-time programs.”</em></p>\n<h1 id=\"meta-axiom-2\">Meta-Axiom #2</h1>\n<p><em>“Any template class accepting a variable number of type parameters can be considered a type container.”</em></p>","frontmatter":{"title":"Practical C++ Metaprogramming","tags":["C++"],"category":"Programming"},"headings":[{"depth":1,"value":"Chapter 1. Introduction"},{"depth":2,"value":"The Early History of Metaprogramming"},{"depth":2,"value":"Enter C++ Templates"},{"depth":1,"value":"Chapter 2. C++ Metaprogramming in Practice"},{"depth":2,"value":"The <code class=\"language-text\">std::tuple&lt;></code> pattern"},{"depth":2,"value":"Returning auto`"},{"depth":1,"value":"Chapter 3. C++ Metaprogramming and Application Design"},{"depth":1,"value":"Meta-Axiom #1"},{"depth":1,"value":"Meta-Axiom #2"}]}},"pageContext":{"id":"aa706932-8843-51f4-852a-d53628010d99","previousPost":{"title":"Rotation Matrix","slug":"/blog/rotation_matrix"},"nextPost":{"title":"Pose and Position","slug":"/blog/pose_and_position"},"dates":{"created":1539787032,"modified":1647509701}}},
    "staticQueryHashes": []}