{
    "componentChunkName": "component---src-templates-blog-post-tsx",
    "path": "/blog/memory_layout",
    "result": {"data":{"site":{"siteMetadata":{"title":"My personal Website"}},"markdownRemark":{"id":"1d1b6799-d1d4-5b82-9786-c65888e89f4f","excerpt":"When a process is started the operating system allocates memory for this process.\nOn modern systems this memory is usually mapped to an virtual address space…","html":"<p>When a process is started the operating system allocates memory for this process.\nOn modern systems this memory is usually mapped to an virtual address space (using the MMU).</p>\n<p>But also on deeply embedded system the compiler and runtime environment need to define a memory\nlayout. In this case there is only one process and there is no virtual memory.</p>\n<h1 id=\"memory-layout-on-different-operating-systems\">Memory Layout on different Operating Systems</h1>\n<p>The use of the memory for a process is different in each operating system.</p>\n<p>This example overwiew is taken from <em>Secure Coding in C and C++, by Robert Seacord</em>:</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/f6651169d27c9ecead62dc85434af272/e9beb/memory_layout.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 50%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsTAAALEwEAmpwYAAABVElEQVQoz22R3W7CMAxGef/3AnFFBRJCpDcUwk9D05bWtZ04aSeaCW3azqWTY322F+M4TjPjjPfeORdjnH4QYxSR6Q8L773W+nq9MnOMMc9zpRQAiAjPhBC6rns8HswMADjjnPPeL2KMMBNCIKKyLI0xiNh1HTMjYl3XiEhEWZatVqvlcnm73VJ98Yk9TRMRpcCpfQrcti0ilmW53W5Pp1PTNEQEAN/yByJKvRBxGIYkp99KqTzP+75PT33f/yMXRWGtFREi+sR2zhljuq4bx1FEQgje+7Ztf8nOuSzLdrtdURTn8xkRmbmuayJ6Pp/GGBFJq2Lmb/kzMzPv9/vD4aC1NsY455LMzCLy834xxtfr9ZaHYQAAZk6x1+v1ZrOpqgoRAcBaS0TGmOPxqJS6XC7pFu+ZY4z3+11rXde1iABAOwMAfd+ng6UJq6qy1jZNk+rOuS841To925FVZAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Memory layouts on different OS&#39;s\"\n        title=\"Memory layouts on different OS&#39;s\"\n        src=\"/static/f6651169d27c9ecead62dc85434af272/f058b/memory_layout.png\"\n        srcset=\"/static/f6651169d27c9ecead62dc85434af272/c26ae/memory_layout.png 158w,\n/static/f6651169d27c9ecead62dc85434af272/6bdcf/memory_layout.png 315w,\n/static/f6651169d27c9ecead62dc85434af272/f058b/memory_layout.png 630w,\n/static/f6651169d27c9ecead62dc85434af272/e9beb/memory_layout.png 730w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>See also <a href=\"http://duartes.org/gustavo/blog/post/anatomy-of-a-program-in-memory/\">Anatomy of a Program in Memory</a></p>\n<h1 id=\"stack-growth\">Stack Growth</h1>\n<p>Depending on the platform the stack grows in different directions:</p>\n<ul>\n<li>Downwards (descending): the stack grows from high adresses to low ones</li>\n<li>Upwards (ascending): it grows from high addresses to low ones</li>\n</ul>\n<p>There is also a distinction on where a stack pointer points to:</p>\n<ul>\n<li>Full: on the last written position.</li>\n<li>Empty: on the position where the next value is going to be written.</li>\n</ul>\n<p>So for example x86 and ARM (usually) have a full descending stack.</p>\n<p><a href=\"http://stackoverflow.com/a/3844164\">Here</a> is a short explanation.</p>\n<p>On most platforms the stack grows downwards. But there are some exeptions.</p>\n<p>This table is an inclomplete (but hopefully correct) overview. Most data in this\ntable is taken from the <a href=\"http://www.freertos.org/\">FreeRTOS</a> code.</p>\n<table>\n<thead>\n<tr>\n<th>Architecture</th>\n<th>Compiler</th>\n<th>Stack growth</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Windows</td>\n<td>MSVC, MingW</td>\n<td>downwards</td>\n</tr>\n<tr>\n<td>POSIX</td>\n<td>GCC</td>\n<td>downwards</td>\n</tr>\n<tr>\n<td>DOS (16Bit)</td>\n<td>Open Watcom</td>\n<td>downwards</td>\n</tr>\n<tr>\n<td><a href=\"%7Bfilename%7D/intel_architecture.md\">x86</a></td>\n<td>any</td>\n<td>downwards</td>\n</tr>\n<tr>\n<td><a href=\"%7Bfilename%7D/arm_cortex_m3_architecture.md\">ARM</a></td>\n<td>any</td>\n<td>downwards</td>\n</tr>\n<tr>\n<td>Renesas 78K0R</td>\n<td>IAR</td>\n<td>downwards</td>\n</tr>\n<tr>\n<td>ARM7 (LPC2xxx, AT91SAM7S, AT91FR40008)</td>\n<td>GCC, RVDS, IAR</td>\n<td>downwards</td>\n</tr>\n<tr>\n<td>ARM Cortex (A5, A9, M0, M4, M3, M7, R4)</td>\n<td>GCC, IAR, RVDS, CCS, Tasking</td>\n<td>downwards</td>\n</tr>\n<tr>\n<td>ATMega323, AVR32 UC3, ATSAM7S64, SAM9XE…</td>\n<td>GCC, IAR</td>\n<td>downwards</td>\n</tr>\n<tr>\n<td>CORTUS APS3</td>\n<td>GCC</td>\n<td>downwards</td>\n</tr>\n<tr>\n<td>Freescale ColdFire</td>\n<td>CodeWarrior, GCC</td>\n<td>downwards</td>\n</tr>\n<tr>\n<td>Cygnal</td>\n<td>SDCC</td>\n<td><strong>upwards</strong></td>\n</tr>\n<tr>\n<td>H8S2329</td>\n<td>GCC</td>\n<td>downwards</td>\n</tr>\n<tr>\n<td>HCS12</td>\n<td>CodeWarrior, GCC</td>\n<td>downwards</td>\n</tr>\n<tr>\n<td>MB91460, MB96340 (Fujitsu)</td>\n<td>Softune</td>\n<td>downwards</td>\n</tr>\n<tr>\n<td>MCF5235</td>\n<td>GCC</td>\n<td>downwards</td>\n</tr>\n<tr>\n<td>TI MSP430</td>\n<td>GCC, IAR, Rowley, CCS</td>\n<td>downwards</td>\n</tr>\n<tr>\n<td>MicroBlaze (IP core)</td>\n<td>GCC</td>\n<td>downwards</td>\n</tr>\n<tr>\n<td>NiosII (IP core)</td>\n<td>GCC</td>\n<td>downwards</td>\n</tr>\n<tr>\n<td>Microchip PIC18</td>\n<td>WizC</td>\n<td>downwards</td>\n</tr>\n<tr>\n<td>Microchip PIC18F</td>\n<td>MPLAB</td>\n<td><strong>upwards</strong></td>\n</tr>\n<tr>\n<td>Microchip PIC24/dsPIC</td>\n<td>MPLAB</td>\n<td><strong>upwards</strong></td>\n</tr>\n<tr>\n<td>Microchip PIC32MX, PIC32MZ</td>\n<td>MPLAB</td>\n<td>downwards</td>\n</tr>\n<tr>\n<td>PowerPC</td>\n<td>GCC</td>\n<td>downwards</td>\n</tr>\n<tr>\n<td>Renesas X100, X200, X600, RL78</td>\n<td>GCC, IAR, Renesas</td>\n<td>downwards</td>\n</tr>\n<tr>\n<td>SH2A_FPU</td>\n<td>Renesas</td>\n<td>downwards</td>\n</tr>\n<tr>\n<td>STMicroelectronics STR71x, STR75x, STR91x</td>\n<td>GCC, IAR</td>\n<td>downwards</td>\n</tr>\n<tr>\n<td>Tern EE</td>\n<td>Paradigm</td>\n<td>downwards</td>\n</tr>\n<tr>\n<td>TriCore 1782</td>\n<td>GCC</td>\n<td>downwards</td>\n</tr>\n<tr>\n<td>V850ES</td>\n<td>IAR</td>\n<td>downwards</td>\n</tr>\n</tbody>\n</table>","frontmatter":{"title":"Memory Layout","tags":["C","C++"],"category":"Programming"},"headings":[{"depth":1,"value":"Memory Layout on different Operating Systems"},{"depth":1,"value":"Stack Growth"}]}},"pageContext":{"id":"1d1b6799-d1d4-5b82-9786-c65888e89f4f","previousPost":{"title":"Agile Software Development","slug":"/blog/agile_sw_development"},"nextPost":{"title":"Endianness","slug":"/blog/endianness"},"dates":{"created":1433862480,"modified":1647509701}}},
    "staticQueryHashes": []}