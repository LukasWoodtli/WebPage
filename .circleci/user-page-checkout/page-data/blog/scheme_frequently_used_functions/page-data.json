{
    "componentChunkName": "component---src-templates-blog-post-tsx",
    "path": "/blog/scheme_frequently_used_functions",
    "result": {"data":{"site":{"siteMetadata":{"title":"My personal Website"}},"markdownRemark":{"id":"9be29ff4-5530-5e85-ba28-fd484e1a3ea0","excerpt":"Pairs (,  and ) : Construct a pair : Get first element of pair (or list) : Get second element of pair (or rest of list) Lists : create a list Equivalent to…","html":"<h1 id=\"pairs-cons-car-and-cdr\">Pairs (<code class=\"language-text\">cons</code>, <code class=\"language-text\">car</code> and <code class=\"language-text\">cdr</code>)</h1>\n<ul>\n<li><code class=\"language-text\">(cons a b)</code>: Construct a pair</li>\n<li><code class=\"language-text\">(car p)</code>: Get first element of pair (or list)</li>\n<li><code class=\"language-text\">(cdr p)</code>: Get second element of pair (or rest of list)</li>\n</ul>\n<h1 id=\"lists\">Lists</h1>\n<ul>\n<li><code class=\"language-text\">(list a0 a1 a2 ... aN)</code>: create a list</li>\n</ul>\n<p>Equivalent to <code class=\"language-text\">(cons (cons a0 (cons a1 (cons a2 (cons ... (cons (cons aN nil))...)))))</code></p>\n<ul>\n<li><code class=\"language-text\">nil</code>: end of list marker (equivalent to the empty list <code class=\"language-text\">'()</code>)</li>\n<li><code class=\"language-text\">(null? p)</code>: checks if the given element is <code class=\"language-text\">nil</code></li>\n<li><code class=\"language-text\">(pair? e)</code>: checks if the given element is a pair</li>\n</ul>\n<blockquote>\n<p>the empty list satisfies <code class=\"language-text\">null?</code> and also is <em>not</em> a pair</p>\n</blockquote>\n<ul>\n<li><code class=\"language-text\">(cons a lst)</code> makes a list like the original one (<code class=\"language-text\">lst</code>), but with an additional item (<code class=\"language-text\">a</code>) at the beginning</li>\n</ul>\n<p>Example:</p>\n<div class=\"gatsby-highlight\" data-language=\"scheme\"><pre class=\"language-scheme\"><code class=\"language-scheme\"><span class=\"token punctuation\">(</span><span class=\"token keyword\">define</span> a <span class=\"token punctuation\">(</span><span class=\"token builtin\">list</span> <span class=\"token number\">1</span> <span class=\"token number\">2</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">(</span><span class=\"token builtin\">cons</span> <span class=\"token number\">10</span> a<span class=\"token punctuation\">)</span>\n>> <span class=\"token punctuation\">(</span><span class=\"token number\">10</span> <span class=\"token number\">1</span> <span class=\"token number\">2</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span></code></pre></div>\n<ul>\n<li><code class=\"language-text\">(list-ref lst i)</code>: retrieves element at index <code class=\"language-text\">i</code> (index is zero-based)</li>\n<li><code class=\"language-text\">(length lst)</code>: returns the length of a list</li>\n<li><code class=\"language-text\">(append lst1 lst2)</code>: combines the elements of two lists into one new list</li>\n<li><code class=\"language-text\">(map fun lst)</code>: applies the function <code class=\"language-text\">fun</code> to each element of <code class=\"language-text\">lst</code> and returns a new list with the results</li>\n</ul>\n<p>The <code class=\"language-text\">map</code> function can be applied on multiple lists:</p>\n<p><em>“This more general <code class=\"language-text\">map</code> takes a procedure of <strong>n</strong> arguments, together with <strong>n</strong> lists, and applies the procedure to all the first elements of the lists, all the second elements of the lists, and so on, returning a list of the results.</em></p>\n<p><em>For example:</em>”</p>\n<div class=\"gatsby-highlight\" data-language=\"scheme\"><pre class=\"language-scheme\"><code class=\"language-scheme\"><span class=\"token punctuation\">(</span><span class=\"token builtin\">map</span> +\n    <span class=\"token punctuation\">(</span><span class=\"token builtin\">list</span> <span class=\"token number\">1</span> <span class=\"token number\">2</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">(</span><span class=\"token builtin\">list</span> <span class=\"token number\">40</span> <span class=\"token number\">50</span> <span class=\"token number\">60</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">(</span><span class=\"token builtin\">list</span> <span class=\"token number\">700</span> <span class=\"token number\">800</span> <span class=\"token number\">900</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n>>> <span class=\"token punctuation\">(</span><span class=\"token number\">741</span> <span class=\"token number\">852</span> <span class=\"token number\">963</span><span class=\"token punctuation\">)</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">(map (lambda (x y) (+ x (* 2 y)))\n    (list 1 2 3)\n    (list 4 5 6))\n>>> (9 12 15)</code></pre></div>\n<p><a href=\"https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-15.html#%25_sec_2.2.1\">SICP:2.2.1  Representing Sequences:Mapping over lists</a></p>\n<ul>\n<li><code class=\"language-text\">(for-each fun lst)</code>: applies a function <code class=\"language-text\">fun</code> to each element in the list <code class=\"language-text\">lst</code> but doesn’t create a new list. The return value of the function is ignored.</li>\n</ul>\n<p><em>“The procedure <code class=\"language-text\">for-each</code> is similar to map. It takes as arguments a procedure and a list of elements. However, rather than forming a list of the results, <code class=\"language-text\">for-each</code> just applies the procedure to each of the elements in turn, from left to right. The values returned by applying the procedure to the elements are not used at all - <code class=\"language-text\">for-each</code> is used with procedures that perform an action, such as printing.”</em></p>\n<p><a href=\"https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-15.html#%25_sec_2.2.1\">SICP:2.2.1  Representing Sequences:Exercise 2.23</a></p>\n<ul>\n<li>\n<p><code class=\"language-text\">(flatten t)</code>: flattens a tree structure into a list</p>\n</li>\n<li>\n<p><code class=\"language-text\">(filter p lst)</code>: Creates a new list with the elements of <code class=\"language-text\">lst</code> for which the predicate <code class=\"language-text\">p</code> is satisfied</p>\n</li>\n<li>\n<p><code class=\"language-text\">(foldr f b lst)</code>: applies the function <code class=\"language-text\">f</code> to the next element of the list and the result of the previous element. <code class=\"language-text\">b</code> is the initial begining value. The list is traversed from right to left. Also known as <code class=\"language-text\">acumulate</code> (<a href=\"https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-15.html#%25_sec_2.2.3\">SICP:2.2.3</a>)</p>\n</li>\n<li>\n<p><code class=\"language-text\">(foldl f b lst)</code>: Same as <code class=\"language-text\">foldlr</code> but the list is traversed from left to right.</p>\n</li>\n<li>\n<p><code class=\"language-text\">(reduce f lst)</code>: Same as <code class=\"language-text\">foldl</code> but take the first (leftmost) element as starting element.</p>\n</li>\n</ul>\n<p>If <code class=\"language-text\">reduce</code> is not available (e.g in Racket) it can be defined in terms of <code class=\"language-text\">foldl</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"scheme\"><pre class=\"language-scheme\"><code class=\"language-scheme\"><span class=\"token punctuation\">(</span><span class=\"token keyword\">define</span> <span class=\"token punctuation\">(</span><span class=\"token function\">reduce</span> f xs<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">(</span><span class=\"token builtin\">and</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">not</span> <span class=\"token punctuation\">(</span><span class=\"token function\">empty?</span> xs<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token function\">foldl</span> f <span class=\"token punctuation\">(</span><span class=\"token function\">first</span> xs<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token function\">rest</span> xs<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p><a href=\"http://stackoverflow.com/a/25211454/1272072\">Stack Overflow</a></p>\n<ul>\n<li><code class=\"language-text\">(memq  v lst)</code>: find element <code class=\"language-text\">v</code> in list <code class=\"language-text\">lst</code> and return the rest of the list starting at the found element. If element is not found <code class=\"language-text\">#f</code> is returned. Similar functions: <code class=\"language-text\">member</code>, <code class=\"language-text\">memv</code>, <code class=\"language-text\">memf</code></li>\n</ul>\n<h1 id=\"local-binding\">Local Binding</h1>\n<p><code class=\"language-text\">let</code> is syntactic sugar for a procedure call:</p>\n<div class=\"gatsby-highlight\" data-language=\"scheme\"><pre class=\"language-scheme\"><code class=\"language-scheme\"><span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token function\">&lt;var></span> &lt;exp><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> &lt;body><span class=\"token punctuation\">)</span></code></pre></div>\n<p>is interpreted as an alternate syntax for</p>\n<div class=\"gatsby-highlight\" data-language=\"scheme\"><pre class=\"language-scheme\"><code class=\"language-scheme\"><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">lambda</span> <span class=\"token punctuation\">(</span><span class=\"token lambda-parameter\">&lt;var></span><span class=\"token punctuation\">)</span> &lt;body><span class=\"token punctuation\">)</span> &lt;exp><span class=\"token punctuation\">)</span></code></pre></div>\n<h1 id=\"delayed-evaluation\">Delayed Evaluation</h1>\n<p><code class=\"language-text\">delay</code> is a special form that returns a <em>delayed object</em>. It is a\n<em>promise</em> to evaluate the given expression at some future time.</p>\n<p><code class=\"language-text\">force</code> takes a <em>delayed object</em> and performs the evaluation. It forces\nthe <code class=\"language-text\">delay</code> to fulfill its promise.</p>\n<p>Delay can be a special form such that:</p>\n<div class=\"gatsby-highlight\" data-language=\"scheme\"><pre class=\"language-scheme\"><code class=\"language-scheme\"><span class=\"token punctuation\">(</span><span class=\"token keyword\">delay</span> &lt;exp><span class=\"token punctuation\">)</span></code></pre></div>\n<p>is syntactic sugar for</p>\n<div class=\"gatsby-highlight\" data-language=\"scheme\"><pre class=\"language-scheme\"><code class=\"language-scheme\"><span class=\"token punctuation\">(</span><span class=\"token keyword\">lambda</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> &lt;exp><span class=\"token punctuation\">)</span></code></pre></div>\n<p>Force simply calls the procedure (of no arguments) pro-\nduced by delay, so we can implement force as a proce-\ndure:</p>\n<div class=\"gatsby-highlight\" data-language=\"scheme\"><pre class=\"language-scheme\"><code class=\"language-scheme\"><span class=\"token punctuation\">(</span><span class=\"token keyword\">define</span> <span class=\"token punctuation\">(</span><span class=\"token function\">force</span> delayed-object<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token function\">delayed-object</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<h1 id=\"dotted-tail-notation\">Dotted-tail Notation</h1>\n<ul>\n<li>Used for functions with arbitrary number of arguments</li>\n</ul>\n<p>Example:</p>\n<div class=\"gatsby-highlight\" data-language=\"scheme\"><pre class=\"language-scheme\"><code class=\"language-scheme\"><span class=\"token punctuation\">(</span><span class=\"token keyword\">define</span> <span class=\"token punctuation\">(</span><span class=\"token function\">x</span> a b . c<span class=\"token punctuation\">)</span> ...<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">(</span><span class=\"token function\">x</span> <span class=\"token number\">1</span> <span class=\"token number\">2</span> <span class=\"token number\">3</span> <span class=\"token number\">4</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">;; in the body of x: a=1, b=2, c='(3 4 5)</span></code></pre></div>","frontmatter":{"title":"Scheme","tags":["Lisp"],"category":"Programming"},"headings":[{"depth":1,"value":"Pairs (<code class=\"language-text\">cons</code>, <code class=\"language-text\">car</code> and <code class=\"language-text\">cdr</code>)"},{"depth":1,"value":"Lists"},{"depth":1,"value":"Local Binding"},{"depth":1,"value":"Delayed Evaluation"},{"depth":1,"value":"Dotted-tail Notation"}]}},"pageContext":{"id":"9be29ff4-5530-5e85-ba28-fd484e1a3ea0","previousPost":{"title":"Closure","slug":"/blog/closure"},"nextPost":{"title":"Structure and Interpretation of Computer Programs","slug":"/blog/sicp"},"dates":{"created":1476416644,"modified":1647509701}}},
    "staticQueryHashes": []}