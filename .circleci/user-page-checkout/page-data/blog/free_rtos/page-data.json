{
    "componentChunkName": "component---src-templates-blog-post-tsx",
    "path": "/blog/free_rtos",
    "result": {"data":{"site":{"siteMetadata":{"title":"My personal Website"}},"markdownRemark":{"id":"8db36564-d81f-5f83-a4aa-28291cd8f338","excerpt":"This page contains some random notes for FreeRTOS. See also: FreeRtosExamples\nand FreeRtos [TOC] Configuration The configuration of the kernel is set in  : This…","html":"<p>This page contains some random notes for FreeRTOS.</p>\n<p>See also: <a href=\"https://github.com/LukasWoodtli/FreeRtosExamples\">FreeRtosExamples</a>\nand <a href=\"http://www.freertos.org/\">FreeRtos</a></p>\n<p>[TOC]</p>\n<h1 id=\"configuration\">Configuration</h1>\n<p>The configuration of the kernel is set in <code class=\"language-text\">FreeRTOSConfig.h</code></p>\n<p><code class=\"language-text\">configTOTAL_HEAP_SIZE</code>: This must be enough space to allocate all\ntasks including the idle task. If the kernel does’t start it could\nbe that the heap is too small.</p>\n<p><code class=\"language-text\">vTaskStartScheduler()</code> returns only if there is <em>not</em> enough memory\nto create the idle task.</p>\n<h1 id=\"tasks\">Tasks</h1>\n<ul>\n<li>Defined as free functions\n<ul>\n<li>Return type: <code class=\"language-text\">void</code></li>\n<li>Argument: <code class=\"language-text\">void *</code></li>\n</ul>\n</li>\n<li>Usally endless loop</li>\n<li>Will never exit (not allowed by kernel)</li>\n<li>A task function can be used to create multiple tasks</li>\n<li>It’s possible to create a task from another task</li>\n</ul>\n<h2 id=\"task-stack-and-tcb\">Task Stack and TCB</h2>\n<p>Each task has its own stack (allocated by the kernel when the\ntask is created).</p>\n<blockquote>\n<p>The stack size is given in <em>number of words</em> and not number of bytes</p>\n</blockquote>\n<p>The stack depth multiplied by the stack width must not be bigger than the maximum value that can be stored in a variable of type size_t.</p>\n<p>The stack size of the idle task is defined by <code class=\"language-text\">configMINIMAL_STACK_SIZE</code>.</p>\n<p>The scheduler maintains a <em>Task Control Block</em> (TCB) for each task.\nEach TCB has the same size.</p>\n<p>Creating a task results in two allocations (<code class=\"language-text\">pvPortMalloc()</code>):</p>\n<ul>\n<li>Task stack</li>\n<li>TCB</li>\n</ul>\n<h1 id=\"stack-overflow\">Stack Overflow</h1>\n<p>FreeRTOS has multiple mechanisms that allow to handle and debug\nstack overflows.</p>\n<h2 id=\"high-water-mark\">High Water Mark</h2>\n<p>The function <code class=\"language-text\">uxTaskGetStackHighWaterMark()</code> returns the minumum\nof avaliable stack space since the task has been started.</p>\n<h2 id=\"runtime-checks\">Runtime Checks</h2>\n<p>There are runtime checks for stack overflow available.</p>\n<ul>\n<li>Checking at task switch</li>\n<li>Fill stack on creation with a pattern, check top of stack for the pattern</li>\n</ul>\n<h3 id=\"method-1\">Method 1</h3>\n<p>After a context switch the kernel checks that the stack pointer\nremains within the valid stack range.</p>\n<p>This method is quick but can miss stack overflows that happen\nbetween context switches.</p>\n<h3 id=\"method-2\">Method 2</h3>\n<p>This method performes additional checks to the ones of method 1.</p>\n<p>At task creation the stack is filled with a known pattern. The last\n20 bytes of the stack are checked for that pattern. If it was\noverwritten a stack overflow occured.</p>\n<p>This method is not as quick as method 1. But it will likely find\nmost (if not all) stack overflows.</p>\n<h3 id=\"configuration-1\">Configuration</h3>\n<ul>\n<li>Set the desired method with <code class=\"language-text\">configCHECK_FOR_STACK_OVERFLOW</code> (value <code class=\"language-text\">1</code> or <code class=\"language-text\">2</code>)</li>\n<li>Implement a hook function: <code class=\"language-text\">vApplicationStackOverflowHook()</code></li>\n</ul>\n<p>The hook function has the prototype:</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">void</span> <span class=\"token function\">vApplicationStackOverflowHook</span><span class=\"token punctuation\">(</span>xTaskHandle <span class=\"token operator\">*</span>pxTask<span class=\"token punctuation\">,</span> <span class=\"token keyword\">signed</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>pcTaskName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Real recovery ofter a stack overflow is not possible.\nSince since the <em>TCB</em> may be corrupted the data privided to the\nhook function may be useless.</p>\n<h2 id=\"task-states\">Task States</h2>\n<p>Only the FreeRTOS kernel is allowed to change task state.</p>\n<ul>\n<li>Running</li>\n<li>Not running\n<ul>\n<li>Suspended</li>\n<li>Ready</li>\n<li>Blocked</li>\n</ul>\n</li>\n</ul>\n<p>Events and system calls can influence the scheduler for allowing\ndifferent tasks to run.</p>\n<p>If more than one task of the same priority is able to run, the scheduler will switch each task in and out of the <em>Running</em> state, in turn.</p>\n<h2 id=\"task-priorities\">Task Priorities</h2>\n<p>Can be assigned a valu form <code class=\"language-text\">0</code> (lowest) to <code class=\"language-text\">configMAX_PRIORITIES - 1</code> (highest).</p>\n<p>Priority can be changed after the scheduler has started but are never changed by the scheduler itself.</p>\n<h3 id=\"selecting-task-priority\">Selecting Task Priority</h3>\n<p>Rule of thumb:</p>\n<p>Tasks for hard real-time functionalities are assigned priorities above tasks for soft real-time functionalities.</p>\n<h4 id=\"rate-monotonic-scheduling-rms\">Rate Monotonic Scheduling (RMS)</h4>\n<p>See <a href=\"https://en.wikipedia.org/wiki/Rate-monotonic_scheduling\">Wikipedia:Rate-monotonic scheduling</a></p>\n<p>Each task is assiged a unique static priority. The priorities are assigned according to the cycle duration of the task.</p>\n<ul>\n<li>Task with the highest execution frequency (shorter cycle) is assigned highest priority is assigned</li>\n<li>Task with the lowest execution frequency is assigned lowest priority is assigned</li>\n</ul>\n<p>RMS maximizes the <em>schedulability</em> of an application.</p>\n<h2 id=\"blocking-a-task\">Blocking a Task</h2>\n<ul>\n<li>A task can be blocked if it currently has nothing to do</li>\n<li><code class=\"language-text\">vTaskDelay()</code> is usually called for a task to enter the blocked state</li>\n<li><code class=\"language-text\">vTaskDelayUntil()</code> should be used when a <em>fixed</em> execution period is required (e.g. DSP)</li>\n</ul>\n<h2 id=\"idle-task-hook\">Idle Task Hook</h2>\n<p>It’s possible to add a callback to the idle task.\nIt is called automatically once per iteration by the idle task loop.</p>\n<p>Following rules must be followed:</p>\n<ul>\n<li>The hook function must never block or suspend itself</li>\n<li>If the application make use of <code class=\"language-text\">vTaskDelete()</code> the hook function needs to return to its caller within reasonable time</li>\n</ul>\n<p>The idle task is responsible to clean up resources after a task has been deleted.</p>\n<h1 id=\"scheduler\">Scheduler</h1>\n<p>The scheduler is executed after each time slice to select the next task.\nA periodic (tick) interrupt is used for switching.</p>\n<p>The tick interrupt frequency is set by <code class=\"language-text\">configTICK_RATE_HZ</code>.</p>\n<p>To convert the number of ticks into milliseconds the constant\n<code class=\"language-text\">portTICK_RATE_MS</code> can be used.</p>\n<h2 id=\"scheduling-algorithm\">Scheduling Algorithm</h2>\n<p>FreeRTOS uses a <em>fixed priority pre-emptive scheduling</em> algorithm. But it can be configured to use a\ncooperative scheduling algorithm.</p>\n<ul>\n<li>Each task has a priority assigned</li>\n<li>Each task has a state</li>\n<li>Only one task is in running state</li>\n<li>The scheduler selects always the highest priority task (in <em>ready</em> state) to enter <em>running</em> state</li>\n</ul>\n<h1 id=\"synchronization\">Synchronization</h1>\n<p>Tasks or ISRs send information to a queue or to a semaphore.\nThese synchronization events are used to signal asynchronous\nactivity.</p>\n<ul>\n<li>Semaphores: communicate events</li>\n<li>Queues: communicate events and data</li>\n</ul>\n<h2 id=\"queues\">Queues</h2>\n<ul>\n<li>Fixed number and size of data items</li>\n<li>FIFO</li>\n<li>Writing and reading: byte-for-byte copy</li>\n<li>Accessible from multiple tasks\n<ul>\n<li>multiple writers is common</li>\n<li>multiple readers is not used often</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"semaphores\">Semaphores</h2>\n<p>Handles to all types of semaphores are stored in variables\nof type <code class=\"language-text\">xSemaphoreHandle</code>.</p>\n<h3 id=\"binary-semaphores\">Binary Semaphores</h3>\n<p>See <a href=\"https://en.wikipedia.org/wiki/Semaphore_(programming)\">Wikipedia:Semaphore</a></p>\n<ul>\n<li>Unblock a task each time an IRQ occurs</li>\n<li>Synchronization of tasks with interrupts</li>\n<li>Deferring processing to handler task</li>\n</ul>\n<p>Terminology:</p>\n<ul>\n<li><span class=\"math math-inline\"><span class=\"katex\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi><mo stretchy=\"false\">(</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">P()</annotation></semantics></math></span></span> operation: ‘taking’ a semaphore</li>\n<li><span class=\"math math-inline\"><span class=\"katex\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mo stretchy=\"false\">(</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">V()</annotation></semantics></math></span></span> operation: ‘giving’ a semaphore</li>\n</ul>\n<p>API function <code class=\"language-text\">xSemaphoreGiveFromISR(..)</code>:</p>\n<ul>\n<li>All types of semapores <em>except recursive semaphores</em> can be</li>\n</ul>\n<p>‘given’ with <code class=\"language-text\">xSemaphoreGiveFromISR()</code>.</p>\n<ul>\n<li>Output argument <code class=\"language-text\">pxHigherPriorityTaskWoken</code>:\n<ul>\n<li>\n<p>if set to pdTRUE a context switch should be performed before ISR exits</p>\n</li>\n<li>\n<p>this context switch needs to be done manually in ISR code</p>\n</li>\n<li>\n<p>the scheduler will switch to the highes prioriy task (in ready state)</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"counting-semaphores\">Counting Semaphores</h3>\n<p>Use cases:</p>\n<ol>\n<li>Counting events\n<ul>\n<li>Count value: difference between number of occured events and number of processed events</li>\n<li>Created with an initial count value of zero</li>\n</ul>\n</li>\n<li>Resource management\n<ul>\n<li>\n<p>Count value: indicates number of available resources</p>\n</li>\n<li>\n<p>Created with an initial count value equal to number of available resources</p>\n</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"critical-sections\">Critical Sections</h1>\n<p>FreeRTOS provides several mechanisms to implement mutual exclusion. But best is if resources are not shared and each resource is accessed only by one single task.</p>\n<h2 id=\"basic-critical-sections\">Basic Critical Sections</h2>\n<p>Critical sections can be wrapped in calls to <code class=\"language-text\">taskENTER_CRITICAL()</code>\nand <code class=\"language-text\">taskEXIT_CRITICAL()</code>. This is a very rudimentary form of mutual exclusion.</p>\n<ul>\n<li>IRQs with priority above <code class=\"language-text\">configMAX_SYSCALL_INTERRUPT_PRIORITY</code> are still allowed to execute</li>\n<li>these interrupts are not allowed to call FreeRTOS API functions</li>\n</ul>\n<p>Critical sections can be nested.</p>\n<h2 id=\"locking-the-scheduler\">Locking the Scheduler</h2>\n<p>The scheduler can be suspended by <code class=\"language-text\">vTaskSuspendAll()</code> and resumed\nby <code class=\"language-text\">xTaskResumeAll()</code>.</p>\n<p>This protects the critical section only from access by other tasks.\nIt leaves interrupts enabled.</p>\n<p>If an interrupt requests an context switch the request is performed\nwhen the scheduler is resumed.</p>\n<blockquote>\n<p>Do not call FreeRTOS API functions while the scheduler is suspended</p>\n</blockquote>\n<p>Locking the scheduler can be nested.</p>\n<h2 id=\"mutexs-and-binary-semaphores\">Mutexs and Binary Semaphores</h2>\n<ul>\n<li>Token that is associated to a shared resource</li>\n<li>Acquire the token before access to the resource is given</li>\n<li>After using the resource the token has to be released</li>\n</ul>\n<p>Mutual exclusion: the semaphore must be returned\nSynchronization: the semaphore is not returned (discarded)</p>\n<h1 id=\"irqs\">IRQs</h1>\n<p>Event processing:</p>\n<ol>\n<li>Detect event\n<ul>\n<li>IRQs</li>\n<li>polling</li>\n</ul>\n</li>\n<li>IRQs\n<ul>\n<li>how much processing in ISR</li>\n<li>how much in main code</li>\n</ul>\n</li>\n<li>Communication of IRS to main code</li>\n</ol>\n<blockquote>\n<p>Only API functions and macros ending in <code class=\"language-text\">FromISR</code> or <code class=\"language-text\">FROM_ISR</code>\nare allowed to be called from interrupt service routines.</p>\n</blockquote>\n<p>The Cortex-M3 allows up to 256 (8 bits) different interrupt priorities.</p>\n<blockquote>\n<p><em>High</em> numeric priority numbers mean <em>low</em> interrupt priority.</p>\n</blockquote>\n<p>There are CMSIS functions that provide access to the interrupt controller.</p>\n<p>Interrupt priorities have nothing to do with task priorities.\nInterrupt priorities are provided by the microcontoller architecture.</p>\n<blockquote>\n<p>Interrupts with higher priorites than\n<code class=\"language-text\">configMAX_SYSCALL_INTERRUPT_PRIORITY</code> (lower value)\nmust not call any FreeRTOS API functions</p>\n</blockquote>\n<h2 id=\"irq-nesting\">IRQ Nesting</h2>\n<p>Interrupt nesting is achieved by setting\n<code class=\"language-text\">configMAX_SYSCALL_INTERRUPT_PRIORITY</code> to a higher priority\n(lower value) than <code class=\"language-text\">configKERNEL_INTERRUPT_PRIORITY</code>.</p>\n<h1 id=\"resources\">Resources</h1>\n<p>Used interrupts on Cortex-M3:</p>\n<ul>\n<li>SysTick</li>\n<li>PendSV</li>\n<li>SVC</li>\n</ul>\n<p>These interrupts are not available for the application.</p>\n<p>Memory (typical sizes):</p>\n<ul>\n<li>Flash: 6 kB</li>\n<li>RAM: 300-500 bytes</li>\n</ul>\n<h2 id=\"reentrancy\">Reentrancy</h2>\n<p>A function that is safe to be called from multiple tasks or ISRs is reentrant.</p>\n<p>Each task has its own stack and its own set of (pushed) registers. If a function only accesses data from its own stack and registers then it is reentrant.</p>\n<h1 id=\"general\">General</h1>\n<h2 id=\"real-time-requirements\">Real-Time Requirements</h2>\n<p>Typically, applications of this type include a mix of both hard and soft real-time requirements</p>\n<ul>\n<li>Soft real-time requirements:\n<ul>\n<li>time deadline</li>\n<li>but breaching deadline does not render the system useles</li>\n<li>i.e. GUI (user interaction)</li>\n</ul>\n</li>\n<li>Hard real-time:\n<ul>\n<li>time deadline</li>\n<li>breaching the deadline: absolute failure of the system</li>\n<li>i.e. security related code in cars</li>\n</ul>\n</li>\n<li>Applications typically combine both types of real-time rocessing</li>\n</ul>\n<h2 id=\"coding-standard\">Coding Standard</h2>\n<p>FreeRTOS has its own coding standard.</p>\n<h3 id=\"data-types\">Data Types</h3>\n<p><code class=\"language-text\">portBASE_TYPE</code>: Most efficient data type on the architecture</p>\n<p><code class=\"language-text\">portTickType</code>: Tick count value to specify block times (16-bit or 32-bit)</p>\n<h3 id=\"variable-and-function-names\">Variable and Function Names</h3>\n<p>Variable Prefixes:</p>\n<ul>\n<li><code class=\"language-text\">c</code>: char</li>\n<li><code class=\"language-text\">s</code>: short</li>\n<li><code class=\"language-text\">l</code>: long</li>\n<li><code class=\"language-text\">x</code>: portBASE_TYPE and others (structs, handles …)</li>\n<li><code class=\"language-text\">u</code>: unsigend (combined with other prefixes)</li>\n<li><code class=\"language-text\">p</code>: pointer (combined with other prefixes)</li>\n</ul>\n<p>Function Names:</p>\n<ul>\n<li>Prefixed with return type and file where the function is defined.</li>\n</ul>\n<p>Defines:</p>\n<table>\n<thead>\n<tr>\n<th>Macro</th>\n<th>Value</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>pdTRUE</td>\n<td>1</td>\n</tr>\n<tr>\n<td>pdFALSE</td>\n<td>0</td>\n</tr>\n<tr>\n<td>pdPASS</td>\n<td>1</td>\n</tr>\n<tr>\n<td>pdFAIL</td>\n<td>0</td>\n</tr>\n</tbody>\n</table>","frontmatter":{"title":"FreeRTOS","tags":["Computer Science","OS","FreeRTOS","Embedded Systems"],"category":"Programming"},"headings":[{"depth":1,"value":"Configuration"},{"depth":1,"value":"Tasks"},{"depth":2,"value":"Task Stack and TCB"},{"depth":1,"value":"Stack Overflow"},{"depth":2,"value":"High Water Mark"},{"depth":2,"value":"Runtime Checks"},{"depth":3,"value":"Method 1"},{"depth":3,"value":"Method 2"},{"depth":3,"value":"Configuration"},{"depth":2,"value":"Task States"},{"depth":2,"value":"Task Priorities"},{"depth":3,"value":"Selecting Task Priority"},{"depth":4,"value":"Rate Monotonic Scheduling (RMS)"},{"depth":2,"value":"Blocking a Task"},{"depth":2,"value":"Idle Task Hook"},{"depth":1,"value":"Scheduler"},{"depth":2,"value":"Scheduling Algorithm"},{"depth":1,"value":"Synchronization"},{"depth":2,"value":"Queues"},{"depth":2,"value":"Semaphores"},{"depth":3,"value":"Binary Semaphores"},{"depth":3,"value":"Counting Semaphores"},{"depth":1,"value":"Critical Sections"},{"depth":2,"value":"Basic Critical Sections"},{"depth":2,"value":"Locking the Scheduler"},{"depth":2,"value":"Mutexs and Binary Semaphores"},{"depth":1,"value":"IRQs"},{"depth":2,"value":"IRQ Nesting"},{"depth":1,"value":"Resources"},{"depth":2,"value":"Reentrancy"},{"depth":1,"value":"General"},{"depth":2,"value":"Real-Time Requirements"},{"depth":2,"value":"Coding Standard"},{"depth":3,"value":"Data Types"},{"depth":3,"value":"Variable and Function Names"}]}},"pageContext":{"id":"8db36564-d81f-5f83-a4aa-28291cd8f338","previousPost":{"title":"Investment Management (Coursera Specialization)","slug":"/blog/investment_management"},"nextPost":{"title":"Git Reset","slug":"/blog/git_reset"},"dates":{"created":1501854983,"modified":1647509701}}},
    "staticQueryHashes": []}