{
    "componentChunkName": "component---src-templates-blog-post-tsx",
    "path": "/blog/scheme",
    "result": {"data":{"site":{"siteMetadata":{"title":"My personal Website"}},"markdownRemark":{"id":"de484f7a-82ea-597b-aa8e-6486d4fa0adf","excerpt":"This page collects notes about Scheme (an Lisp in general). [TOC] Sources Most information is taken from: Structure and Interpretation of\nComputer\nPrograms See…","html":"<p>This page collects notes about Scheme (an Lisp in general).</p>\n<p>[TOC]</p>\n<h2 id=\"sources\">Sources</h2>\n<p>Most information is taken from: <a href=\"http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/\">Structure and Interpretation of\nComputer\nPrograms</a></p>\n<p>See also <a href=\"/blog/sicp\">my notes on Structure and Interpretation of Computer\nPrograms</a></p>\n<p><a href=\"https://github.com/LukasWoodtli/SchemeCourse\">My Github repository with examples</a></p>\n<h2 id=\"evaluation-rules\">Evaluation Rules</h2>\n<ol>\n<li>If <em>self-evaluating</em>: return value</li>\n<li>If <em>name</em>: return value of associated name in environment</li>\n<li>If <em>special form</em>: do something special</li>\n<li>If <em>combination</em>:\n<ol>\n<li><em>evaluate</em> all subexpressions (in any order)</li>\n<li><em>apply</em> operator on arguments and return result</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"application-rules\">Application Rules</h2>\n<ol>\n<li>If <em>primitive procedure</em>, just do it</li>\n<li>If <em>compound procedure</em>, then <em>evaluate</em> body of procedure with each\n<em>formal</em> parameter replaced with corresponding <em>actual</em> argument\nvalue.</li>\n</ol>\n<h2 id=\"linear-recursion-and-iteration\">Linear Recursion and Iteration</h2>\n<p>See <a href=\"https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-11.html#%25_sec_1.2.1\">SICP section 1.2.1</a>\nand <a href=\"http://stackoverflow.com/questions/17254240/sicp-recursive-process-vs-iterative-process-using-a-recursive-procedure-to-gene\">stack overflow</a></p>\n<p>It’s confusing that both the recursive and the iterative implementation\ncall themselves. There is a distinction between</p>\n<ul>\n<li>Recursive process and</li>\n<li>Recursive function</li>\n</ul>\n<p>A recursive function calls itself. But it can be implemented as\n<em>recursive</em> or <em>iterative</em> process.</p>\n<table>\n<thead>\n<tr>\n<th>Recursive Process</th>\n<th>Iterative Process</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Function calls itself</td>\n<td>Function calls itself</td>\n</tr>\n<tr>\n<td>Itermediate result is kept on caller side</td>\n<td>Intermedia result is passed to the called function: additional argument needed, initial value needed</td>\n</tr>\n<tr>\n<td>Each recursive call needs a new stack frame</td>\n<td>Stack frame can be reused (tail call)</td>\n</tr>\n<tr>\n<td>Recursive function call part of bigger expression</td>\n<td>Recursive function call not part of bigger expression</td>\n</tr>\n<tr>\n<td>Easier to understand</td>\n<td>More difficult to understand and to implement</td>\n</tr>\n<tr>\n<td>Needs stack</td>\n<td>Can be implemented in register machine (without stack)</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"recursive-process\">Recursive Process</h3>\n<div class=\"gatsby-highlight\" data-language=\"scheme\"><pre class=\"language-scheme\"><code class=\"language-scheme\"><span class=\"token punctuation\">(</span><span class=\"token keyword\">define</span> <span class=\"token punctuation\">(</span><span class=\"token function\">factorial</span> n<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">=</span> n <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    <span class=\"token number\">1</span>\n    <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span> n <span class=\"token punctuation\">(</span><span class=\"token function\">factorial</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">-</span> n <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">;; 'factorial' is part of bigger expression</span></code></pre></div>\n<h3 id=\"iterative-process\">Iterative Process</h3>\n<div class=\"gatsby-highlight\" data-language=\"scheme\"><pre class=\"language-scheme\"><code class=\"language-scheme\"><span class=\"token punctuation\">(</span><span class=\"token keyword\">define</span> <span class=\"token punctuation\">(</span><span class=\"token function\">factorial</span> n<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">(</span><span class=\"token function\">fact-iter</span> <span class=\"token number\">1</span> <span class=\"token number\">1</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">;; inital values need to be provided</span>\n\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">define</span> <span class=\"token punctuation\">(</span><span class=\"token function\">fact-iter</span> product counter max-count<span class=\"token punctuation\">)</span> <span class=\"token comment\">;; max-cout: intermediate result</span>\n  <span class=\"token punctuation\">(</span><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">></span> counter max-count<span class=\"token punctuation\">)</span>\n       product\n       <span class=\"token punctuation\">(</span><span class=\"token function\">fact-iter</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span> counter product<span class=\"token punctuation\">)</span>\n                  <span class=\"token punctuation\">(</span><span class=\"token operator\">+</span> counter <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n                  max-count<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">;; max-cout: supply intermediate result to next call</span></code></pre></div>\n<ul>\n<li>Iterative algorithms have constant space</li>\n<li>Develop iterative algorithm:\n<ul>\n<li>figure out a way to accumulate partial answers</li>\n<li>write out table to analyze precisely\n<ul>\n<li>initialization of first row</li>\n<li>update rules for other rows</li>\n<li>how to know when to stop</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Iterative algorithms have no pending operations when the procedure\ncalls itself</li>\n</ul>\n<h2 id=\"expressions\">Expressions</h2>\n<ul>\n<li>In Scheme everything is an expression</li>\n<li>Expressions can be nested arbritarly</li>\n</ul>\n<h2 id=\"sequences-as-conventional-interfaces\">Sequences as Conventional Interfaces</h2>\n<p><em>“The key to organizing programs so as to more clearly reflect the\nsignal-flow structure is to concentrate on the “signals” that flow\nfrom one stage in the process to the next. If we represent these signals\nas lists, then we can use list operations to implement the processing at\neach of the stages.</em>”</p>\n<p><em>“The value of expressing programs as sequence operations is that this\nhelps us make program designs that are modular, that is, designs that\nare constructed by combining relatively independent pieces. We can\nencourage modular design by providing a library of standard components\ntogether with a conventional interface for connecting the components in\nflexible ways.”</em></p>\n<p><a href=\"https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-15.html#%25_sec_2.2.3\">SICP section 2.2.3 Sequences as Conventional Interfaces</a></p>\n<h2 id=\"lazy-evaluation\">Lazy Evaluation</h2>\n<p>Normal-order (lazy) evaluation doesn’t work well in some cases:</p>\n<ul>\n<li>Tail recursion (Iterative Process): the stack frame can’t be reused\nbecause computation of a promise is not executed until it’s needed.\nThe delayed promises let the stack grow until their computation is\nforced.</li>\n<li>Side effects: Setting variables to values calculated by promises is\ndifficult because it’s not clear when the promise is forced to\ncalculate the value. The time decoupling mechanism of promises\n(streams) doesn’t work well with statefull models where time is of\nessence.</li>\n</ul>\n<h2 id=\"quotation\">Quotation</h2>\n<p><em>“Allowing quotation in a language wreaks havoc with the ability to\nreason about the language in simple terms, because it destroys the\nnotion that equals can be substituted for equals. For example, three is\none plus two, but the word “three” is not the phrase “one plus two”.\nQuotation is powerful because it gives us a way to build expressions\nthat manipulate other expressions”</em></p>\n<p><a href=\"https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-16.html#%25_sec_2.3.1\">SICP section 2.3.1 Quotation</a></p>\n<h2 id=\"backquote\">Backquote</h2>\n<p>Preceding a list with a backquote symbol (`) is much like quoting it,\nexcept that anything in the list that is flagged with a comma is\nevaluated.</p>\n<p><a href=\"https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-35.html#%25_sec_5.5.2\">SICP section 5.5.2 Compiling Expressions</a></p>","frontmatter":{"title":"Scheme (Lisp)","tags":["Lisp"],"category":"Programming"},"headings":[{"depth":2,"value":"Sources"},{"depth":2,"value":"Evaluation Rules"},{"depth":2,"value":"Application Rules"},{"depth":2,"value":"Linear Recursion and Iteration"},{"depth":3,"value":"Recursive Process"},{"depth":3,"value":"Iterative Process"},{"depth":2,"value":"Expressions"},{"depth":2,"value":"Sequences as Conventional Interfaces"},{"depth":2,"value":"Lazy Evaluation"},{"depth":2,"value":"Quotation"},{"depth":2,"value":"Backquote"}]}},"pageContext":{"id":"de484f7a-82ea-597b-aa8e-6486d4fa0adf","previousPost":{"title":"Evaluation strategy","slug":"/blog/evaluation_strategy"},"nextPost":{"title":"Lernen","slug":"/blog/lernen"},"dates":{"created":1612193753,"modified":1647509701}}},
    "staticQueryHashes": []}